<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/postgresql%E6%B8%85%E7%90%86%E8%A1%A8%E7%A9%BA%E9%97%B4/"/>
    <url>/2024/08/12/postgresql%E6%B8%85%E7%90%86%E8%A1%A8%E7%A9%BA%E9%97%B4/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在用postgresql查询数据的时候，发现有个表的查询一直很慢，这里暂且取名A表，但是数据量并没有特别大，才几万的数据量，而且发现跟这个表同schema的数据表有个几千万的，但是查询都比这个A表快很多。后来查找了一系列资料发现，是A表占用的空间太大，会影响查询的性能，使用命令查看发现大概有4G左右的磁盘查勇，而几千万的那个表占用空间才几百M，于是使用命令清理了A表的磁盘占用，处理完之后就几十M的空间，而且查询变得很快。</p><h1 id="处理步骤"><a href="#处理步骤" class="headerlink" title="处理步骤"></a>处理步骤</h1><h2 id="1-查看表占用空间大小"><a href="#1-查看表占用空间大小" class="headerlink" title="1.查看表占用空间大小"></a>1.查看表占用空间大小</h2><p>pg里面查看表空间大小有好几种方式，如下：</p><h3 id="1-1-dt-命令"><a href="#1-1-dt-命令" class="headerlink" title="1.1 \dt+ 命令"></a>1.1 \dt+ 命令</h3><p>这是 psql 命令行中的命令,可以列出所有表及其大小信息, 如:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">postgres=<span class="hljs-comment"># \dt+ t1</span><br>            List of relations<br>Schema |<span class="hljs-string">   Name   </span>|<span class="hljs-string"> Type </span>|<span class="hljs-string">  Owner  </span>|<span class="hljs-string"> Size </span>|<span class="hljs-string"> Description </span><br><span class="hljs-string">--------+--------------+-------+-----------+-------+-------------</span><br><span class="hljs-string">public </span>|<span class="hljs-string"> t1      </span>|<span class="hljs-string"> table </span>|<span class="hljs-string"> postgres </span>|<span class="hljs-string"> 16 MB </span>|<span class="hljs-string"> </span><br></code></pre></td></tr></table></figure><h3 id="1-2-pg-total-relation-size-函数"><a href="#1-2-pg-total-relation-size-函数" class="headerlink" title="1.2 pg_total_relation_size() 函数"></a>1.2 pg_total_relation_size() 函数</h3><p>这个函数可以直接查询一个表的大小,如:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">sql</span><br><span class="hljs-keyword">SELECT</span> pg_total_relation_size(<span class="hljs-string">&#x27;t1&#x27;</span>);<br></code></pre></td></tr></table></figure><h3 id="1-3-pg-size-pretty-函数"><a href="#1-3-pg-size-pretty-函数" class="headerlink" title="1.3 pg_size_pretty() 函数"></a>1.3 pg_size_pretty() 函数</h3><p>这个函数可以将字节大小转换为人类比较方便阅读的模式:</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">sql</span><br><span class="hljs-keyword">SELECT</span> pg_size_pretty(pg_total_relation_size(<span class="hljs-string">&#x27;t1&#x27;</span>));<br>输出：<br><span class="hljs-number">16</span>MB<br></code></pre></td></tr></table></figure><h2 id="2-清理磁盘空间"><a href="#2-清理磁盘空间" class="headerlink" title="2.清理磁盘空间"></a>2.清理磁盘空间</h2><p> VACUUM FULL 是 PostgreSQL 中的一个命令,用于对表进行完整的垃圾回收和碎片整理。</p><p> VACUUM FULL 命令会做以下操作:</p><h3 id="2-1-完整回收未使用的空间"><a href="#2-1-完整回收未使用的空间" class="headerlink" title="2.1 完整回收未使用的空间"></a>2.1 完整回收未使用的空间</h3><p>普通的 VACUUM 命令只会回收此刻可以回收的空间,但有些空间必须等到事务结束才可以回收。VACUUM FULL 会等待所有事务结束,彻底回收所有未使用空间。</p><p>###2.2 重写表数据</p><p>VACUUM FULL 会重写表中的每一行,整理存储碎片,压缩表空间。</p><h3 id="2-3-重建索引"><a href="#2-3-重建索引" class="headerlink" title="2.3 重建索引"></a>2.3 重建索引</h3><p>VACUUM FULL 会重建表所有的索引,整理索引碎片并压缩索引空间。</p><p>###2.4 更新统计信息</p><p>VACUUM FULL 会重新计算表的统计信息, 包括行数、空间大小等。</p><p>###2.5 清理回滚段</p><p>VACUUM FULL 会缩小和清空回滚段,释放更多空间。</p><p><strong>注：使用VACUUM FULL或者VACUUM不会锁表</strong></p><p> 所以VACUUM FULL 应该谨慎执行, 最好是业务比较空间的时候执行，一般建议每隔几个月执行一次。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.数据表在频繁的更新，写入，删除等操作会产生大量的磁盘碎片导致性能下降，使用VACUUM或者VACUUM FULL可以清理掉多余的空间</p><p>2.不过要注意因为VACUUM FULL本身清理也会有较大的性能消耗，而且会锁表，所以使用的时候要谨慎，不要在业务频繁调用的时候清理</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/JavaShutDownHook%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/08/12/JavaShutDownHook%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h1><p>之前有了解过Java的ShutDown Hook机制，但是因为没有使用场景也没有深入学习，最近刚好又看到ShutDown Hook的一些东西，想着学习总结一下，做下学习记录。Java的Shutdown Hook是一种机制，允许开发者在Java虚拟机（JVM）即将关闭之前执行一些清理或终止操作。Shutdown Hook提供了一个钩子，允许开发者在JVM关闭时捕获到关闭事件并执行相应的逻辑。以下是一些使用场景：</p><ol><li>资源释放和清理：当应用程序结束或JVM关闭时，可以使用Shutdown Hook来释放和清理打开的文件、网络连接、数据库连接等资源。这确保资源在程序终止之前得到适当的关闭，避免资源泄露和数据丢失。</li><li>日志记录和统计：Shutdown Hook可以用于记录应用程序的关键统计信息或生成最终的日志报告。通过在JVM关闭前执行这些操作，可以捕获应用程序在运行期间的关键数据，并生成相应的日志记录。</li><li>缓存刷新：如果应用程序使用了缓存机制，可以在JVM关闭前使用Shutdown Hook来刷新缓存，将缓存中的数据写回到持久化存储或其他目标中，确保数据的持久化和一致性。</li><li>任务终止和状态保存：在某些情况下，可能需要在应用程序终止时保存任务的当前状态，以便在下次启动时恢复。通过在Shutdown Hook中执行任务的状态保存操作，可以将任务的状态保存到持久化存储中，并在下次启动时进行恢复。</li><li>线程管理：Shutdown Hook还可以用于管理和终止应用程序中的线程。在JVM关闭前，可以使用Shutdown Hook发送终止信号给正在运行的线程，以确保它们在终止之前完成当前任务并进行清理操作。</li></ol><p>上面说的这些使用场景，我都没用到过，大家可以先了解一下对ShutDownHook有一个简单的认识。</p><h1 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h1><p>下面我们从源码上去看一下，ShutDown Hook的方法和原理。</p><p>跟它相关的主要有两个类ApplicationShutdownHooks和Runtime</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationShutdownHooks</span> &#123;<br>    <span class="hljs-comment">/* The set of registered hooks */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Shutdown.<span class="hljs-keyword">add</span>(<span class="hljs-number">1</span> <span class="hljs-comment">/* shutdown hook invocation order */</span>,<br>                <span class="hljs-literal">false</span> <span class="hljs-comment">/* not registered if shutdown in progress */</span>,<br>                <span class="hljs-keyword">new</span> Runnable() &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                        runHooks();<br>                    &#125;<br>                &#125;<br>            );<br>            hooks = <span class="hljs-keyword">new</span> IdentityHashMap&lt;&gt;();<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalStateException e) &#123;<br>            <span class="hljs-comment">// application shutdown hooks cannot be added if</span><br>            <span class="hljs-comment">// shutdown is in progress.</span><br>            hooks = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ApplicationShutdownHooks</span>()</span> &#123;&#125;<br><br>    <span class="hljs-comment">/* Add a new shutdown hook.  Checks the shutdown state and the hook itself,</span><br><span class="hljs-comment">     * but does not do any security checks.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> synchronized <span class="hljs-keyword">void</span> <span class="hljs-title">add</span>(<span class="hljs-params">Thread hook</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(hooks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Shutdown in progress&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (hook.isAlive())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Hook already running&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (hooks.containsKey(hook))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Hook previously registered&quot;</span>);<br><br>        hooks.put(hook, hook);<br>    &#125;<br><br>    <span class="hljs-comment">/* Remove a previously-registered hook.  Like the add method, this method</span><br><span class="hljs-comment">     * does not do any security checks.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> synchronized boolean <span class="hljs-title">remove</span>(<span class="hljs-params">Thread hook</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(hooks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Shutdown in progress&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (hook == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><br>        <span class="hljs-keyword">return</span> hooks.<span class="hljs-keyword">remove</span>(hook) != <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/* Iterates over all application hooks creating a new thread for each</span><br><span class="hljs-comment">     * to run in. Hooks are run concurrently and this method waits for</span><br><span class="hljs-comment">     * them to finish.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runHooks</span>()</span> &#123;<br>        Collection&lt;Thread&gt; threads;<br>        synchronized(ApplicationShutdownHooks.<span class="hljs-keyword">class</span>) &#123;<br>            threads = hooks.keySet();<br>            hooks = <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Thread hook : threads) &#123;<br>            hook.start();<br>        &#125;<br>        <span class="hljs-keyword">for</span> (Thread hook : threads) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                hook.<span class="hljs-keyword">join</span>();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException x) &#123; &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">-- Runtime.class里面的方法<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addShutdownHook</span><span class="hljs-params">(Thread hook)</span> &#123;<br>       <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>       <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>           sm.checkPermission(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimePermission</span>(<span class="hljs-string">&quot;shutdownHooks&quot;</span>));<br>       &#125;<br>       ApplicationShutdownHooks.add(hook);<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeShutdownHook</span><span class="hljs-params">(Thread hook)</span> &#123;<br>       <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>       <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>           sm.checkPermission(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimePermission</span>(<span class="hljs-string">&quot;shutdownHooks&quot;</span>));<br>       &#125;<br>       <span class="hljs-keyword">return</span> ApplicationShutdownHooks.remove(hook);<br>   &#125;<br><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">halt</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span> &#123;<br>       <span class="hljs-type">SecurityManager</span> <span class="hljs-variable">sm</span> <span class="hljs-operator">=</span> System.getSecurityManager();<br>       <span class="hljs-keyword">if</span> (sm != <span class="hljs-literal">null</span>) &#123;<br>           sm.checkExit(status);<br>       &#125;<br>       Shutdown.halt(status);<br>   &#125;<br></code></pre></td></tr></table></figure><p>结合这两个类的源码，我们可以看到添加Hook其实是往ApplicationShutdownHooks的静态Map里面放入新的线程，但是这些线程只是创建后被保存了起来，只有当程序退出时，runHooks被执行，每一个带有Hook任务的线程才的start()方法才被执行，也因为Hook之间是相互独立的线程，所以它们之间执行是没有顺序的，而且因为主线程调用了每个Hook的线程的join方法，所以主线程会等待Hook全部执行完毕在退出。</p><h2 id="无法被添加的情况："><a href="#无法被添加的情况：" class="headerlink" title="无法被添加的情况："></a>无法被添加的情况：</h2><figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl"> <span class="hljs-function"><span class="hljs-title">if</span>(<span class="hljs-variable">hooks</span> == <span class="hljs-variable"><span class="hljs-literal">null</span></span>)</span><br>         <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">IllegalStateException</span>(<span class="hljs-string">&quot;Shutdown in progress&quot;</span>);</span><br><span class="hljs-function"><span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">hook.isAlive</span>())</span><br>     <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hook already running&quot;</span>);</span><br><span class="hljs-function"></span><br><span class="hljs-function"> <span class="hljs-variable"><span class="hljs-keyword">if</span></span> (<span class="hljs-variable">hooks.containsKey</span>(<span class="hljs-variable">hook</span>))</span><br>     <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-function"><span class="hljs-title">IllegalArgumentException</span>(<span class="hljs-string">&quot;Hook previously registered&quot;</span>);</span><br></code></pre></td></tr></table></figure><p>1.ApplicationShutdownHooks已经在调用Hook时，hooks会置为null，不能在添加hook</p><p>2.Hook的Thread不能是已经在运行状态的线程</p><p>3.因为储存的Hook是根据线程是否相同来判断的，所以同样的Hook无法被添加</p><h2 id="不适用的情况："><a href="#不适用的情况：" class="headerlink" title="不适用的情况："></a>不适用的情况：</h2><p>1.因为ShutDown Hook只能处理正常退出的情况，kill -9这种是无法处理的</p><p>2Shutdown.halt和kill -9一样都是强制退出，不会给Hook执行的机会</p><h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><p>下面放了一些简单的测试ShutDown的小例子，<a href="https://github.com/wxwwt/java-practice/tree/master/src/main/java/com/scott/java/task/shutdown/hook">github地址</a>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Test<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span>()</span> &#123;<br>       <span class="hljs-comment">// 测试正常退出的情况</span><br>       Runtime.getRuntime().addShutdownHook(<br>               <span class="hljs-keyword">new</span> Thread(<br>                       () -&gt; &#123;<br>                           System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>                       &#125;)<br>       );<br>   &#125;<br>   <br>   输出：hook1 执行了<br></code></pre></td></tr></table></figure><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">@Test<br>   public <span class="hljs-keyword">void</span> test2() &#123;<br>       <span class="hljs-regexp">//</span> 测试Hook执行顺序是否真的无序<br>       Runtime.getRuntime().addShutdownHook(<br>               <span class="hljs-keyword">new</span> Thread(<br>                       <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123;<br>                           System.out.println(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>                       &#125;)<br>       );<br><br>       Runtime.getRuntime().addShutdownHook(<br>               <span class="hljs-keyword">new</span> Thread(<br>                       <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123;<br>                           System.out.println(<span class="hljs-string">&quot;hook2 执行了&quot;</span>);<br>                       &#125;)<br>       );<br>   &#125;<br>   <br>   输出：输出结果hook1和hook2会随机打印，没有固定顺序<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Test<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test3</span>()</span> &#123;<br>       <span class="hljs-comment">// 测试kill -9 会执行Hook吗</span><br>       Runtime.getRuntime().addShutdownHook(<br>               <span class="hljs-keyword">new</span> Thread(<br>                       () -&gt; &#123;<br>                           System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>                       &#125;)<br>       );<br><br>       <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br><br>       &#125;<br><br>   &#125;<br>   <br>   输出：<br></code></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Test<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test4</span>()</span> &#123;<br>    <span class="hljs-comment">// 测试oom时 会执行Hook吗</span><br>    Runtime.getRuntime().addShutdownHook(<br>            <span class="hljs-keyword">new</span> Thread(<br>                    () -&gt; &#123;<br>                        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>                    &#125;)<br>    );<br><br>   <br>    List&lt;Object&gt; list = Lists.newArrayList();<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>       list.<span class="hljs-keyword">add</span>(<span class="hljs-keyword">new</span> ShutDownHookTest());<br>    &#125;<br>&#125;<br><br>输出：<br>  java.lang.OutOfMemoryError: GC overhead limit exceeded<br><br>     at com.scott.java.task.shutdown.hook.ShutDownHookTest.test4(ShutDownHookTest.java:<span class="hljs-number">74</span>)<br>     。。。省略不重要的日志<br><br>     hook1 执行了<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Test<br>   <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> test5() &#123;<br>       <span class="hljs-comment">// 测试移除Hook后，会执行Hook吗</span><br>       <span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>       &#125;);<br><br>       Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">thread</span>);<br>       Runtime.getRuntime().removeShutdownHook(<span class="hljs-keyword">thread</span>);<br>   &#125;<br>   <br>   输出：<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Test<br><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> test6() &#123;<br>    <span class="hljs-comment">// 测试执行halt方法后，会执行Hook吗</span><br>    <span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>    &#125;);<br><br>    Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">thread</span>);<br>    Runtime.getRuntime().halt(<span class="hljs-number">111</span>);<br>&#125;<br>输出：<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Test<br>   <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> test7() &#123;<br>       <span class="hljs-comment">// 测试已经执行Hook时，还能添加新的hook吗</span><br>       <span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(() -&gt; &#123;<br>           System.out.println(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>           Run<br>       &#125;);<br><br>       Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">thread</span>);<br>       Runtime.getRuntime().halt(<span class="hljs-number">111</span>);<br>   &#125;<br>   输出：<br>   hook1 执行了<br>Exception <span class="hljs-keyword">in</span> <span class="hljs-keyword">thread</span> <span class="hljs-string">&quot;Thread-0&quot;</span> java.lang.IllegalStateException: Shutdown <span class="hljs-keyword">in</span> progress<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs lasso">@Test<br>  <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> test8() &#123;<br>      <span class="hljs-comment">// 测试重复注册后，会执行Hook吗</span><br>      <span class="hljs-keyword">Thread</span> <span class="hljs-keyword">thread</span> = <span class="hljs-literal">new</span> <span class="hljs-keyword">Thread</span>(() -&gt; &#123;<br>          System.out.println(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>      &#125;);<br><br>      Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">thread</span>);<br>      Runtime.getRuntime().addShutdownHook(<span class="hljs-keyword">thread</span>);<br>  &#125;<br>  <br>  输出：java.lang.IllegalArgumentException: Hook previously registered<br></code></pre></td></tr></table></figure><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino">@<span class="hljs-function">Test</span><br><span class="hljs-function">  <span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">test9</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-comment">// 测试重复注册后，会执行Hook吗</span><br>      Thread thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Thread</span>(() -&gt; &#123;<br>          System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;hook1 执行了&quot;</span>);<br>      &#125;);<br><br>      thread.<span class="hljs-built_in">start</span>();<br>      Runtime.<span class="hljs-built_in">getRuntime</span>().<span class="hljs-built_in">addShutdownHook</span>(thread);<br>  &#125;<br>  <br>  输出：<br>      hook1 执行了<br><br>  java.lang.IllegalArgumentException: Hook already running<br></code></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>1.ShutDown的使用还是比较简单，网上也有分析Spring和Dubbo等开源框架的使用例子，基本上都是用于销毁处理资源释放的问题</p><p>2.稍微要注意的就是一些特殊情况，比如hook执行是无序的，不能重复添加相同的hook，已经执行的hook不能再创建新的hook等</p><p>3.平时基本没用到过ShutDown Hook，自己想到一个比较有用的场景就是Jvm挂了，在Hook里面给监控程序发通知发邮件之类的，让技术人员来处理</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://docs.oracle.com/javase/8/docs/technotes/guides/lang/hook-design.html">1.oracle官网资料</a></p><p><a href="https://segmentfault.com/a/1190000040167517">2.Java Shutdown Hook 场景使用和源码分析</a></p><p><a href="https://www.baeldung.com/jvm-shutdown-hooks">3.Adding Shutdown Hooks for JVM Applications</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/08/12/hadoop%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="hadoop分布式缓存的使用"><a href="#hadoop分布式缓存的使用" class="headerlink" title="hadoop分布式缓存的使用"></a>hadoop分布式缓存的使用</h3><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>DistributedCache是hadoop框架提供的一种机制,可以将job指定的文件,在job执行前,先行分发到task执行的机器上,并有相关机制对cache文件进行管理。<br>缓存内容是在文件中的，各个节点可以根据hdfs中访问路径来读取缓存。</p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><p>1.添加分布式缓存的时候，<br>先定义缓存的路径</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">String cacheFile <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://xxxx&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>可以设置别名 “#”号后面的就是别名 在方法中可以直接使用<br>cacheFile &#x3D; cacheFile + “#别名”<br>在main方法中添加到job中（然后在map阶段就可以使用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 缓存jar包到task运行节点的classpath中</span><br>job.addArchiveToClassPath(archive);<br><span class="hljs-comment">// 缓存普通文件到task运行节点的classpath中</span><br>job.addFileToClassPath(file);<br><span class="hljs-comment">// 缓存压缩包文件到task运行节点的工作目录</span><br>job.addCacheArchive(uri);<br><span class="hljs-comment">// 缓存普通文件到task运行节点的工作目录</span><br>job.addCacheFile(uri)<br></code></pre></td></tr></table></figure><p>2.使用分布式缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">(Mapper&lt;LongWritable, Text, Text, Text&gt;.Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>    <span class="hljs-built_in">super</span>.setup(context);<br>    <span class="hljs-comment">// 读取缓存文件中的内容 直接根据别名读取</span><br>        <span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;别名&quot;</span>);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr)；<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/hadoop%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/"/>
    <url>/2024/08/12/hadoop%E5%AE%9E%E7%8E%B0%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%B9%98/</url>
    
    <content type="html"><![CDATA[<h1 id="hadoop-实现矩阵相乘"><a href="#hadoop-实现矩阵相乘" class="headerlink" title="hadoop 实现矩阵相乘"></a>hadoop 实现矩阵相乘</h1><p>我们大学里学过矩阵相乘，如下，当两个矩阵A，B，A的行等于B的列时可以相乘。然后乘积是A的行乘以B的列得出。我们今天用hadoop来实现一下矩阵的乘法。<br>$$<br>    \left[<br>  \begin{matrix}<br>   A1 &amp;  A2 &amp;  A3 \<br>    A4 &amp;  A5 &amp;  A6 \<br>    A7 &amp;  A8 &amp;  A9<br>  \end{matrix}<br>  \right]<br>  X<br>     \left[<br>  \begin{matrix}<br>   B1 &amp; B2 &amp; B3 \<br>   B4 &amp; B5 &amp; B6 \<br>   B7 &amp; B8 &amp; B9<br>  \end{matrix}<br>  \right]<br>$$</p><p>计算过程是A行乘以B列，我们可以将B先转置（行列互换），然后在用A行乘以B行可以得出结果，具体步骤如下：<br>1.将B（下面可以理解为右边的矩阵）转置，结果输出B’<br>2.AxB’(B’的结果放在hdfs的文件系统缓存中)，输出结果</p><p>我们先看一下例子的两个矩阵数据<br>$$<br>    \left[<br>  \begin{matrix}<br>   1 &amp;  2 &amp;  -1 \<br>    2 &amp;  1 &amp;  3 \<br>    0 &amp;  3 &amp;  1<br>  \end{matrix}\tag{A}<br>  \right]<br>$$<br>$$<br>     \left[<br>  \begin{matrix}<br>   1 &amp; 2 &amp; 3 \<br>   3 &amp; -1 &amp; 0 \<br>   -4 &amp; 2 &amp; 1<br>  \end{matrix}\tag{B}<br>  \right]<br>$$<br>我们定义放在hdfs文件中数据形式如下<br>1 1_1,2_2,3_-1<br>2 1_2,2_2,3_3<br>3 1_0,2_3,3_1<br>一行的最左边是行号，右边的是数据，“1_1”这种左边是列号，右边是数据值</p><p>代码部分：<br>第一步：将B（下面可以理解为右边的矩阵）转置，结果输出B’<br>Map阶段：<br>将右矩阵的数据读入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapMatrixTranspose</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, Text&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * key:1</span><br><span class="hljs-comment">     * values:1_1,2_2,3_-1,4_0</span><br><span class="hljs-comment">     * 1    1_-1,2_1,3_4,4_3,5_2</span><br><span class="hljs-comment">     * 2    1_4,2_6,3_4,4_6,5_1</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 说明：矩阵与矩阵相乘（左行X右列），考虑到hadoop是按行读取，所以需要先将右矩阵进行转置，变成（左行X右行）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-comment">//按行获取内容，每次读取一行（元素与元素之间以tab键分割）；</span><br>        String[] rowAndLines = values.toString().split(<span class="hljs-string">&quot;\t&quot;</span>);<br>        <span class="hljs-comment">//行号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">row</span> <span class="hljs-operator">=</span> rowAndLines[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">//每行内容</span><br>        String[] lines = rowAndLines[<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-comment">//循环输出内容 key:列号   value:行号_值，行号_值，行号_值，行号_值</span><br>        <span class="hljs-keyword">for</span> (String line : lines) &#123;<br>            <span class="hljs-comment">//获取列号</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">colunm</span> <span class="hljs-operator">=</span> line.split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">0</span>];<br>            <span class="hljs-comment">//获取每列的值</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> line.split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">1</span>];<br>            outKey.set(colunm);<br>            outValue.set(row + <span class="hljs-string">&quot;_&quot;</span> + value);<br>            <span class="hljs-comment">//输出</span><br>            context.write(outKey, outValue);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Reducer阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReduceMatrixTranspose</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, Text, Text, Text&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outValues</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key     输入的列号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> values  行号 值，行号 值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;Text&gt; values, Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (Text text : values) &#123;<br>            sb.append(text).append(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (sb.toString().endsWith(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>            result = sb.substring(<span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        outKey.set(key);<br>        outValues.set(Objects.requireNonNull(result));<br>        context.write(outKey, outValues);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>Main：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Transpose</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hdfs地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">hdfs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://localhost:9000&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 创建conf配置</span><br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br>        <span class="hljs-comment">// 设置hdfs地址</span><br>        conf.set(<span class="hljs-string">&quot;fs.defaultFS&quot;</span>, hdfs);<br>        <span class="hljs-comment">// 创建job实例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance(conf, <span class="hljs-string">&quot;step1&quot;</span>);<br>            <span class="hljs-comment">//设置job主类</span><br>            job.setJarByClass(Transpose.class);<br>            <span class="hljs-comment">//设置job的map类与reduce类</span><br>            job.setMapperClass(MapMatrixTranspose.class);<br>            job.setReducerClass(ReduceMatrixTranspose.class);<br>            <span class="hljs-comment">//设置mapper输出类型</span><br>            job.setMapOutputKeyClass(Text.class);<br>            job.setMapOutputValueClass(Text.class);<br>            <span class="hljs-comment">//设置reduce输出类型</span><br>            job.setOutputKeyClass(Text.class);<br>            job.setOutputValueClass(Text.class);<br>            <span class="hljs-type">FileSystem</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> FileSystem.get(conf);<br>            <span class="hljs-comment">//设置输入、输出路径</span><br>            FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">0</span>]));<br>            FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">1</span>]));<br>            <span class="hljs-keyword">if</span> (job.waitForCompletion(<span class="hljs-literal">true</span>)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;matrix transpose success&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;matrix transpose fail&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行异常&quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将代码打成jar包，将左矩阵的数据放入到hdfs中，运行hadoop命令。</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">hadoop <span class="hljs-keyword">jar </span>matrix.<span class="hljs-keyword">jar </span>文件路径 输出路径<br></code></pre></td></tr></table></figure><p>在查看输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hadoop fs -cat 输出结果的文件<br></code></pre></td></tr></table></figure><p>得出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>3_-<span class="hljs-number">4</span>,<span class="hljs-number">2_3</span>,<span class="hljs-number">1_1</span><br><span class="hljs-number">2</span><span class="hljs-number">3_2</span>,2_-<span class="hljs-number">1</span>,<span class="hljs-number">1_2</span><br><span class="hljs-number">3</span><span class="hljs-number">3_1</span>,<span class="hljs-number">2_0</span>,<span class="hljs-number">1_3</span><br></code></pre></td></tr></table></figure><p>第二步：AxB’(B’的结果放在hdfs的文件系统缓存中)，输出结果<br>Map阶段：<br>这里从分布式缓存中读取了右矩阵right_matrix的值，这个别名是在main方法里面设置的，用法可以参考：<a href=""></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MapMatrixMultiply</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Mapper</span>&lt;LongWritable, Text, Text, Text&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; cacheList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化方法</span><br><span class="hljs-comment">     * 会在map方法之前执行一次，且只执行一次</span><br><span class="hljs-comment">     * 作用：将转置的右侧矩阵放在list中</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setup</span><span class="hljs-params">(Mapper&lt;LongWritable, Text, Text, Text&gt;.Context context)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-built_in">super</span>.setup(context);<br>        <span class="hljs-comment">// 读取缓存文件中的内容</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileReader</span> <span class="hljs-variable">fr</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(<span class="hljs-string">&quot;right_matrix&quot;</span>);<br>             <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">br</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(fr)) &#123;<br>            String line;<br>            <span class="hljs-keyword">while</span> ((line = br.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                cacheList.add(line);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * map实现方法</span><br><span class="hljs-comment">     * key:行</span><br><span class="hljs-comment">     * values:行 tab 列_值,列_值,列_值,列_值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">map</span><span class="hljs-params">(LongWritable key, Text values, Context context)</span><br>            <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-comment">// 左矩阵</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">rowMatrix1</span> <span class="hljs-operator">=</span> values.toString().split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">0</span>];<br>        String[] columnValueArrayMatrix1 = values.toString().split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;,&quot;</span>);<br>        <span class="hljs-keyword">for</span> (String line : cacheList) &#123;<br>            <span class="hljs-comment">// 右矩阵行数据</span><br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">rowMatrix2</span> <span class="hljs-operator">=</span> line.split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">0</span>];<br>            String[] columnValueArrayMatrix2 = line.toString().split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 遍历左矩阵每一行的每一列</span><br>            <span class="hljs-keyword">for</span> (String columnValueMatrix1 : columnValueArrayMatrix1) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">columnMatrix1</span> <span class="hljs-operator">=</span> columnValueMatrix1.split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">0</span>];<br>                <span class="hljs-type">String</span> <span class="hljs-variable">columnValue1</span> <span class="hljs-operator">=</span> columnValueMatrix1.split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">1</span>];<br>                <span class="hljs-keyword">for</span> (String columnValueMatrix2 : columnValueArrayMatrix2) &#123;<br>                    <span class="hljs-comment">// 判断前缀相同，进行相乘</span><br>                    <span class="hljs-keyword">if</span> (columnValueMatrix2.startsWith(columnMatrix1 + <span class="hljs-string">&quot;_&quot;</span>)) &#123;<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">columnValue2</span> <span class="hljs-operator">=</span> columnValueMatrix2.split(<span class="hljs-string">&quot;_&quot;</span>)[<span class="hljs-number">1</span>];<br>                        result += Integer.valueOf(columnValue1) * Integer.valueOf(columnValue2);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            outKey.set(rowMatrix1);<br>            outValue.set(rowMatrix2 + <span class="hljs-string">&quot;_&quot;</span> + result);<br>            context.write(outKey, outValue);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Reducer阶段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReduceMatrixMultiply</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Reducer</span>&lt;Text, Text, Text, Text&gt; &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outKey</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Text</span> <span class="hljs-variable">outValue</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Text</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reduce</span><span class="hljs-params">(Text key, Iterable&lt;Text&gt; values, Context context)</span><br>            <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span> (Text text : values) &#123;<br>            sb.append(text).append(<span class="hljs-string">&quot;,&quot;</span>);<br>        &#125;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (sb.toString().endsWith(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>            result = sb.substring(<span class="hljs-number">0</span>, sb.length() - <span class="hljs-number">1</span>);<br>        &#125;<br><br>        outKey.set(key);<br>        outValue.set(Objects.requireNonNull(result));<br>        context.write(outKey, outValue);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Main：<br>在这里设置了hdfs分布式缓存的路径，通过args[0]传入的，然后在map阶段进行了调用，#文件名，就是给它取的别名。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Multiply</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * hdfs地址</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">String</span> <span class="hljs-variable">hdfs</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hdfs://localhost:9000&quot;</span>;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Configuration</span> <span class="hljs-variable">conf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Configuration</span>();<br><br>        conf.set(<span class="hljs-string">&quot;fs.defaultFS&quot;</span>, hdfs);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 创建job实例</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Job</span> <span class="hljs-variable">job</span> <span class="hljs-operator">=</span> Job.getInstance(conf, <span class="hljs-string">&quot;matrix_multiply&quot;</span>);<br>            <span class="hljs-comment">//添加分布式缓存文件</span><br>            job.addCacheArchive(<span class="hljs-keyword">new</span> <span class="hljs-title class_">URI</span>(args[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;#right_matrix&quot;</span>));<br>            <span class="hljs-comment">//设置job主类</span><br>            job.setJarByClass(Transpose.class);<br>            <span class="hljs-comment">//设置job的map类与reduce类</span><br>            job.setMapperClass(MapMatrixMultiply.class);<br>            job.setReducerClass(ReduceMatrixMultiply.class);<br><br>            job.setMapOutputKeyClass(Text.class);<br>            job.setMapOutputValueClass(Text.class);<br><br>            job.setOutputKeyClass(Text.class);<br>            job.setOutputValueClass(Text.class);<br><br>            <span class="hljs-type">FileSystem</span> <span class="hljs-variable">fs</span> <span class="hljs-operator">=</span> FileSystem.get(conf);<br>            <span class="hljs-comment">//设置 输入、输出路径</span><br>            FileInputFormat.addInputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">1</span>]));<br>            FileOutputFormat.setOutputPath(job, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Path</span>(args[<span class="hljs-number">2</span>]));<br><br>            <span class="hljs-keyword">if</span> (job.waitForCompletion(<span class="hljs-literal">true</span>)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;matrix transpose success&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;matrix transpose fail&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行异常&quot;</span> + e.getMessage());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">hadoop jar matrix2.jar 分布式缓存地址 输入地址 输出地址<br></code></pre></td></tr></table></figure><p>得到结果,大功告成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span><span class="hljs-number">3_2</span>,2_-<span class="hljs-number">2</span>,<span class="hljs-number">1_11</span><br><span class="hljs-number">2</span><span class="hljs-number">3_9</span>,<span class="hljs-number">2_9</span>,1_-<span class="hljs-number">7</span><br><span class="hljs-number">3</span><span class="hljs-number">3_1</span>,2_-<span class="hljs-number">1</span>,<span class="hljs-number">1_5</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/hadoop%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/08/12/hadoop%E5%8D%95%E6%9C%BA%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h3 id="引语"><a href="#引语" class="headerlink" title="引语:"></a>引语:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;最近想接触一些大数据相关的技术,所以有了这篇文章,其实就是记录一下自己学习hadoop的过程,如果文章中有啥写的不对的地方,还望指正(有java开发经验,但是是大数据小白一只,各位大神轻喷.)<br>我先是在网上搜索了一波大数据应该要学些什么技术,基本上不约而同的都是指向了hadoop.<br>&nbsp;&nbsp;&nbsp;&nbsp;摘自维基百科:<a href="https://zh.wikipedia.org/zh-hans/Apache_Hadoop">Apache Hadoop链接地址</a>.看完维基百科描述,我们大概知道了hadoop是一个分布式的大数据框架，在深入一些我们会知道<br>它是由很多个组件组成的（比如核心的HDFS，Hadoop Distributed File System，Mapreduce框架，还有很多Hive，HBase等等）。所以hadoop其实也是代指hadoop的一套的生态系统。光说不练假把式，好的我们来看看怎么安装，搭建hadoop的环境呢？</p><h3 id="安装步骤："><a href="#安装步骤：" class="headerlink" title="安装步骤："></a>安装步骤：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;这里其实有个前提，默认各位大佬的机器上已经安装好了linux和java环境。如果没有可以动动您灵活的手指，在搜索栏敲下“如何安装linux&#x2F;java环境”,不开玩笑了，这个比较常见。<br>hadoop安装官网上说是有三种方式：<br>1.单机模式安装<br>2.伪分布式安装<br>3.全分布式安装（真.分布式）<br>我这里使用的是伪分布式，有人要问为啥不用真.分布式呢？<br>第一是初学者学会了伪分布式，基本上全分布式也是不会有大问题的，只是机器多了；<br>第二是因为贫穷，<br><img src="https://user-gold-cdn.xitu.io/2019/7/28/16c3905e69d9cd25?w=240&h=210&f=jpeg&s=8476"><br>在云服务器上搭建的，全分布式要搞好几台。2333~ 开个玩笑啦,主要是懒~</p><h4 id="1-下载hadoop"><a href="#1-下载hadoop" class="headerlink" title="1.下载hadoop"></a>1.下载hadoop</h4><p>去官网下载就可以了，<a href="http://hadoop.apache.org/">官网链接</a>。<br><img src="https://user-gold-cdn.xitu.io/2019/7/28/16c3905e69c5e216?w=1466&h=434&f=png&s=73361"><br>点击source，然后在跳转的页面中下载hadoop-3.1.2-src.tar.gz。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf hadoop-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span>-src.tar.gz<br></code></pre></td></tr></table></figure><p>然后进入到 hadoop-3.1.2中，目录是这样<br><img src="https://user-gold-cdn.xitu.io/2019/7/28/16c3905e6a8701a0?w=146&h=256&f=png&s=5541"><br>bin和sbin是可执行脚本的目录，etc是放hadoop配置文件的目录。</p><h4 id="2-配置hadoop"><a href="#2-配置hadoop" class="headerlink" title="2.配置hadoop"></a>2.配置hadoop</h4><p>(1).首先先配置hadoop的环境文件hadoop-env.sh，进入到hadoop-3.1.2&#x2F;etc&#x2F;hadoop目录下，编辑 hadoop-env.sh文件<br>然后搜索JAVA_HOME,会发现两处，但是可以通过阅读英文注释得知是哪一个</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># Technically, the only required environment variable is JAVA_HOME.</span><br><span class="hljs-comment"># All others are optional.  However, the defaults are probably not</span><br><span class="hljs-comment"># preferred.  Many sites configure these options outside of Hadoop,</span><br><span class="hljs-comment"># such as in /etc/profile.d</span><br><br><span class="hljs-comment"># The java implementation to use. By default, this environment</span><br><span class="hljs-comment"># variable is REQUIRED on ALL platforms except OS X!</span><br></code></pre></td></tr></table></figure><p>在这下面添加export JAVA_HOME&#x3D;“机器上的jdk地址”</p><p>在环境变量中添加hadoop的配置，vim &#x2F;etc&#x2F;profile,添加hadoop_home</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> HADOOP_HOME=/home/hadoop/hadoop-3.1.2<br><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:<span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$HADOOP_HOME</span>/sbin:<span class="hljs-variable">$HADOOP_HOME</span>/bin<br></code></pre></td></tr></table></figure><p>(2).在配置hadoop的核心配置文件core-site.xml，这里配置的是hdfs的NameNode地址和数据存储目录路径<br>在<configuration>里面添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">这个是hdfs的地址<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>fs.defaultFS<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>hdfs://wxwwt-hadoop:9000<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>hadoop存储数据路径<br><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hadoop.tmp.dir<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>/home/hadoop/hadoop-3.1.2/data<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>wxwwt-hadoop这个是自己随便取得名字，记得在etc&#x2F;hosts中配置一下，映射到本地127.0.0.1</p><p>(3).配置mapred-site.xml，从名字上就能看出来是和MapReduce相关的。指定一下调度系统的配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mapreduce.framework.name<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>yarn<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br></code></pre></td></tr></table></figure><p>(4).配置yarn-site.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>指定ResouceManager的地址<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.resourcemanager.hostname<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>wxwwt-hadoop<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>指定MapReduce的方式<br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>yarn.nodemanager.aux-services<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>mapreduce_shuffle<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>到这里已经上hadoop的配置文件是弄完了</p><h4 id="3-格式化文件系统"><a href="#3-格式化文件系统" class="headerlink" title="3.格式化文件系统"></a>3.格式化文件系统</h4><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">hdfs namenode -<span class="hljs-built_in">format</span><br></code></pre></td></tr></table></figure><p>如果能看到类似下面的信息，说明格式化成功了</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Storage</span> directory /home/hadoop/hadoop-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span>/data/dfs/name has been successfully formatted.<br></code></pre></td></tr></table></figure><h4 id="4-运行hadoop，start-dfs-sh"><a href="#4-运行hadoop，start-dfs-sh" class="headerlink" title="4.运行hadoop，start-dfs.sh"></a>4.运行hadoop，start-dfs.sh</h4><p>不过在运行之前，先得说一句如果之前一直使用的root用户的话，这里运行会报错。因为会因为是root用户，hadoop不建议使用root用户。会报出</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">ERROR: </span>Attempting to operate on hdfs namenode as root<br><span class="hljs-keyword">ERROR: </span>but there is no HDFS_NAMENODE_USER defined. Aborting operation.<br>Starting datanodes<br><span class="hljs-keyword">ERROR: </span>Attempting to operate on hdfs datanode as root<br><span class="hljs-keyword">ERROR: </span>but there is no HDFS_DATANODE_USER defined. Aborting operation.<br></code></pre></td></tr></table></figure><p>类似的错误。<br>(1).如果想用root用户继续执行的话，得在启动脚本start-dfs.sh中添加</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">HDFS_DATANODE_USER</span>=root<br><span class="hljs-attr">HADOOP_SECURE_DN_USER</span>=hdfs<br><span class="hljs-attr">HDFS_NAMENODE_USER</span>=root<br><span class="hljs-attr">HDFS_SECONDARYNAMENODE_USER</span>=root<br></code></pre></td></tr></table></figure><p>并且要设置root的免密登录。<br>步骤：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">ssh-keygen -t rsa -P <span class="hljs-string">&#x27;&#x27;</span> -f ~/.ssh/id_rsa</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">chmod</span> 0600 ~/.ssh/authorized_keys</span><br></code></pre></td></tr></table></figure><p>(2).如果要使用其他用户的话，先得将hadoop的目录权限给这个用户添加下<br>比如：我要使用wxwwt用户来操作</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">useradd</span> wxwwt<br><span class="hljs-attribute">passwd</span> wxwwt<br><span class="hljs-attribute">chown</span> -R wxwwt:wxwwt /home/hadoop-<span class="hljs-number">3</span>.<span class="hljs-number">1</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">su</span> wxwwt<br></code></pre></td></tr></table></figure><p>设置用用户名密码，将hadoop目录权限给wxwwt，然后切换用户。再设置免密登录</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript">ssh-keygen -t rsa<br>ssh-<span class="hljs-keyword">copy</span>-<span class="hljs-built_in">id</span> localhost<br></code></pre></td></tr></table></figure><p>然后在运行hadoop。</p><p>start-hdfs.sh执行完，看下jps如果出现了NameNode，SecondaryNameNode，DataNode的进程就是HDFS启动成功了</p><h4 id="5-启动yarn，start-yarn-sh。"><a href="#5-启动yarn，start-yarn-sh。" class="headerlink" title="5.启动yarn，start-yarn.sh。"></a>5.启动yarn，start-yarn.sh。</h4><p>启动完后再看下jps，如图出现了ResourceManager，NodeManager就大功告成。<br><img src="https://user-gold-cdn.xitu.io/2019/7/28/16c3905e6c8fe075?w=335&h=124&f=png&s=6359"></p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.hadoop的一些简单概念，它也是一个大的生态系统；<br>2.hadoop安装分三种模式，单机，伪分布式，全分布式；文中介绍的是伪分布式，就是在一台机器上弄的；<br>3.安装中主要就是按教程添加配置，但是其中还是有坑的，记住启动的时候root的坑，和免密登录。</p><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1.<a href="https://hadoop.apache.org/docs/r3.1.2/hadoop-project-dist/hadoop-common/SingleCluster.html%EF%BC%88%E5%AE%98%E7%BD%91%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%99%E7%A8%8B%EF%BC%89">https://hadoop.apache.org/docs/r3.1.2/hadoop-project-dist/hadoop-common/SingleCluster.html（官网伪分布式教程）</a><br>2.<a href="https://blog.csdn.net/solaraceboy/article/details/78438336%EF%BC%88%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95%E6%95%99%E7%A8%8B%EF%BC%89">https://blog.csdn.net/solaraceboy/article/details/78438336（免密登录教程）</a><br>3.<a href="https://blog.csdn.net/whq12789/article/details/79782020">https://blog.csdn.net/whq12789/article/details/79782020</a><br>4.<a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-yarn/%EF%BC%88yarn%E4%BB%8B%E7%BB%8D%EF%BC%89">https://www.ibm.com/developerworks/cn/opensource/os-cn-hadoop-yarn/（yarn介绍）</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/hive%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/08/12/hive%E7%9A%84%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h4 id="hive的安装和配置"><a href="#hive的安装和配置" class="headerlink" title="hive的安装和配置"></a>hive的安装和配置</h4><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1.先从官网下载hive的压缩包 <a href="http://www.apache.org/dyn/closer.cgi/hive/">下载地址</a><br>这里我下载的是hive-3.1.2<br><img src="http://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/article_picture/hive%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/hive3.1.2%E5%AE%98%E7%BD%91.png"></p><p>2.配置hive，进入到hive的conf目录下，将默认的配置文件复制一份</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd hive/conf/<br>cp hive-default.xml.template hive-site.xml<br>vim hive-site.xml<br></code></pre></td></tr></table></figure><p>配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span> standalone=<span class="hljs-string">&quot;no&quot;</span>?&gt;</span><br><span class="hljs-meta">&lt;?xml-stylesheet type=<span class="hljs-string">&quot;text/xsl&quot;</span> href=<span class="hljs-string">&quot;configuration.xsl&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionURL<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- mysql数据库中的地址  这里要先创建对应的数据库 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>jdbc:mysql://mysql的host地址:3306/hive_test<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库的账号的密码 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionDriverName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>com.mysql.jdbc.Driver<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionUserName<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>root<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>javax.jdo.option.ConnectionPassword<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>XXXX<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>hive.metastore.schema.verification<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这里要注意的就是hive_test是预先创建好的，文章中没有步骤，需要自己去创建一下对应的数据库</p><p>4.将mysql的驱动放入到hive目录的lib下，如果没有这个包可以从maven本地仓库去找或者maven的远程仓库，<a href="https://mvnrepository.com/artifact/mysql/mysql-connector-java">maven远程仓库下载mysql驱动地址</a></p><p>5.在hive中初始化mysql的数据库</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">schematool -dbType mysql -initSchema</span><br></code></pre></td></tr></table></figure><p>这一步可能会报错，有可能是mysql版本问题或者是权限设置问题<br>比如说权限问题可能会报下面这个错：<br><img src="http://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/article_picture/hive%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE/%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98.jpg"></p><p>这里hive执行sql脚本会使用到外键，如果当前账号没有开启refernce的权限就回有问题。</p><p>6.启动hadoop，（这里默认大家之前都安装过hadoop了，如果没有的话可以参考<a href="https://juejin.im/post/5d3db3b2e51d457761476235">hadoop安装记录</a>）<br>运行start-all.sh,启动完成后。</p><p>7.输入命令hive，然后</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">create datebase test <span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>如果去mysql中hive_test查询</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> DBS<br></code></pre></td></tr></table></figure><p>DB_LOCATION_URI有对应的数据出现就是安装hive成功了~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/remove%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2024/08/12/remove%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="遍历集合类的时候删除元素"><a href="#遍历集合类的时候删除元素" class="headerlink" title="遍历集合类的时候删除元素"></a>遍历集合类的时候删除元素</h3><h3 id="导语："><a href="#导语：" class="headerlink" title="导语："></a>导语：</h3><p>最近写了一个bug就是在遍历list的时候删除了里面一个元素，其实之前看过阿里的java开发规范，知道在遍历的时候删除元素会产生问题，但是写的快的时候还是会没注意到，那正好研究下里面的机制看。我们看看阿里规范怎么写的：<br><img src="http://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/article_picture/remove%E9%9B%86%E5%90%88%E7%B1%BB%E5%85%83%E7%B4%A0/%E9%98%BF%E9%87%8C%E8%A7%84%E8%8C%83.png"></p><p>首先提出一个概念：fail-fast<br>摘自百度百科：<br>fail-fast 机制是java集合(Collection)中的一种错误机制。当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。<br>例如：当某一个线程A通过iterator去遍历某集合的过程中，若该集合的内容被其他线程所改变了；那么线程A访问集合时，就会抛出ConcurrentModificationException异常，产生fail-fast事件。<br>简单来说是java为了防止出现并发异常的一个机制，但是其实在单线程下也可以产生。</p><h3 id="实例分析："><a href="#实例分析：" class="headerlink" title="实例分析："></a>实例分析：</h3><p>接下来，我会通过6个例子来探究下，遍历list时删除元素会发生什么，和它的源码探究。<br>前提先造了一个list：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;<br>       add(<span class="hljs-string">&quot;元素1&quot;</span>);<br>       add(<span class="hljs-string">&quot;元素2&quot;</span>);<br>       add(<span class="hljs-string">&quot;元素3&quot;</span>);<br>   &#125;&#125;;<br></code></pre></td></tr></table></figure><h4 id="1-普通的for循环"><a href="#1-普通的for循环" class="headerlink" title="1.普通的for循环"></a>1.普通的for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test1</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size() - <span class="hljs-number">1</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素3&quot;</span>.equals(list.get(i))) &#123;<br>               System.out.println(<span class="hljs-string">&quot;找到元素3了&quot;</span>);<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素2&quot;</span>.equals(list.get(i))) &#123;<br>               list.remove(i);<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-comment">//  这里不会输出找到元素3 因为遍历到元素2的时候删除了元素2 list的size变小了</span><br>   <span class="hljs-comment">//  所以就产生问题了</span><br></code></pre></td></tr></table></figure><h4 id="2-for循环另一种情况"><a href="#2-for循环另一种情况" class="headerlink" title="2.for循环另一种情况"></a>2.for循环另一种情况</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test2</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; list.size() - <span class="hljs-number">1</span>; i++) &#123;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素2&quot;</span>.equals(list.get(i))) &#123;<br>               list.remove(i);<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素3&quot;</span>.equals(list.get(i))) &#123;<br>               System.out.println(<span class="hljs-string">&quot;找到元素3了&quot;</span>);<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-comment">// 这里会输出元素3 但是其实是在遍历到元素2的时候输出的</span><br>   <span class="hljs-comment">// 遍历到元素2 然后删除 到了判断元素3的条件的时候i是比原来小了1</span><br>   <span class="hljs-comment">// 所以又阴差阳错的输出了正确结果</span><br></code></pre></td></tr></table></figure><h4 id="3-增强for循环"><a href="#3-增强for循环" class="headerlink" title="3.增强for循环"></a>3.增强for循环</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">for</span> (String item : list) &#123;<br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素2&quot;</span>.equals(item)) &#123;<br>               list.remove(item);<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素3&quot;</span>.equals(item)) &#123;<br>               System.out.println(<span class="hljs-string">&quot;找到元素3了&quot;</span>);<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-comment">// 这里和上面的结果有点不一样 但是还是没有输出元素3的打印语句</span><br>   <span class="hljs-comment">// 这里反编译下java文件就可以知道是为啥啦</span><br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test3</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-type">Iterator</span> <span class="hljs-variable">var1</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.list.iterator();<br><br>         <span class="hljs-keyword">while</span>(var1.hasNext()) &#123;<br>           <span class="hljs-comment">// 为了显示区别这里</span><br>             <span class="hljs-type">String</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> (String)var1.next();<br>             <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素2&quot;</span>.equals(var2)) &#123;<br>                 <span class="hljs-built_in">this</span>.list.remove(var2);<br>             &#125;<br><br>             <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素3&quot;</span>.equals(var2)) &#123;<br>                 System.out.println(<span class="hljs-string">&quot;找到元素3了&quot;</span>);<br>             &#125;<br>         &#125;<br><br>     &#125;<br></code></pre></td></tr></table></figure><p>反编译的文件可以知道这里增强for反编译是用了迭代器，来判断是否还有元素，然后remove用的是list的方法。<br>我们看下ArrayList中的hasNext(),next()是怎么写的。下面是ArrayList中的内部类Itr实现了Iterator接口，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-type">int</span> cursor;       <span class="hljs-comment">// index of next element to return</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <span class="hljs-comment">// index of last element returned; -1 if no such</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br><br>        Itr() &#123;&#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> cursor != size;<br>        &#125;<br><br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            checkForComodification();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            cursor = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>            checkForComodification();<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>                cursor = lastRet;<br>                lastRet = -<span class="hljs-number">1</span>;<br>                expectedModCount = modCount;<br>            &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEachRemaining</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; consumer)</span> &#123;<br>            Objects.requireNonNull(consumer);<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> ArrayList.<span class="hljs-built_in">this</span>.size;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">final</span> Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>            &#125;<br>            <span class="hljs-keyword">while</span> (i != size &amp;&amp; modCount == expectedModCount) &#123;<br>                consumer.accept((E) elementData[i++]);<br>            &#125;<br>            <span class="hljs-comment">// update once at end of iteration to reduce heap write traffic</span><br>            cursor = i;<br>            lastRet = i - <span class="hljs-number">1</span>;<br>            checkForComodification();<br>        &#125;<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>这里cursor在next()执行时，cursor &#x3D; i + 1，所以当运行到”元素2”.equal(item)这里，元素2被移除，当遍历当元素3的时候size &#x3D; 2.cursor &#x3D; i + 1 &#x3D; 1 + 1 也是2.<br>hasNext()中cursor &#x3D;&#x3D; size就直接退出了。</p><h4 id="4-foreach"><a href="#4-foreach" class="headerlink" title="4.foreach"></a>4.foreach</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test4</span><span class="hljs-params">()</span> &#123;<br>        list.forEach(<br>                item -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素2&quot;</span>.equals(item)) &#123;<br>                        list.remove(item);<br>                    &#125;<br><br>                    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素3&quot;</span>.equals(item)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;找到元素3了&quot;</span>);<br>                    &#125;<br>                &#125;<br>        );<br>    &#125;<br>    <span class="hljs-comment">// 这里抛出了我们期待已经的fail-fast java.util.ConcurrentModificationException</span><br></code></pre></td></tr></table></figure><p>点进去看下ArrayList的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>       Objects.requireNonNull(action);<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>       <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>       <span class="hljs-keyword">final</span> E[] elementData = (E[]) <span class="hljs-built_in">this</span>.elementData;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.size;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;<br>           action.accept(elementData[i]);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>根据报错信息我们可以知道是<br>if (modCount !&#x3D; expectedModCount) {<br>    throw new ConcurrentModificationException();<br>}<br>抛出的异常，那么这个modCount元素是从哪里来的？<br>我们找到AbstractList,这个是ArrayList的父类。<br>看看源码里面是怎么说的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * The number of times this list has been &lt;i&gt;structurally modified&lt;/i&gt;.</span><br><span class="hljs-comment">    * Structural modifications are those that change the size of the</span><br><span class="hljs-comment">    * list, or otherwise perturb it in such a fashion that iterations in</span><br><span class="hljs-comment">    * progress may yield incorrect results.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt;This field is used by the iterator and list iterator implementation</span><br><span class="hljs-comment">    * returned by the &#123;<span class="hljs-doctag">@code</span> iterator&#125; and &#123;<span class="hljs-doctag">@code</span> listIterator&#125; methods.</span><br><span class="hljs-comment">    * If the value of this field changes unexpectedly, the iterator (or list</span><br><span class="hljs-comment">    * iterator) will throw a &#123;<span class="hljs-doctag">@code</span> ConcurrentModificationException&#125; in</span><br><span class="hljs-comment">    * response to the &#123;<span class="hljs-doctag">@code</span> next&#125;, &#123;<span class="hljs-doctag">@code</span> remove&#125;, &#123;<span class="hljs-doctag">@code</span> previous&#125;,</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@code</span> set&#125; or &#123;<span class="hljs-doctag">@code</span> add&#125; operations.  This provides</span><br><span class="hljs-comment">    * &lt;i&gt;fail-fast&lt;/i&gt; behavior, rather than non-deterministic behavior in</span><br><span class="hljs-comment">    * the face of concurrent modification during iteration.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * &lt;p&gt;&lt;b&gt;Use of this field by subclasses is optional.&lt;/b&gt; If a subclass</span><br><span class="hljs-comment">    * wishes to provide fail-fast iterators (and list iterators), then it</span><br><span class="hljs-comment">    * merely has to increment this field in its &#123;<span class="hljs-doctag">@code</span> add(int, E)&#125; and</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@code</span> remove(int)&#125; methods (and any other methods that it overrides</span><br><span class="hljs-comment">    * that result in structural modifications to the list).  A single call to</span><br><span class="hljs-comment">    * &#123;<span class="hljs-doctag">@code</span> add(int, E)&#125; or &#123;<span class="hljs-doctag">@code</span> remove(int)&#125; must add no more than</span><br><span class="hljs-comment">    * one to this field, or the iterators (and list iterators) will throw</span><br><span class="hljs-comment">    * bogus &#123;<span class="hljs-doctag">@code</span> ConcurrentModificationExceptions&#125;.  If an implementation</span><br><span class="hljs-comment">    * does not wish to provide fail-fast iterators, this field may be</span><br><span class="hljs-comment">    * ignored.</span><br><span class="hljs-comment">    */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> <span class="hljs-variable">modCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>英文好的同学可以自己看下，英文不好的同学可以默默打开谷歌翻译或者有道词典了。</p><p>剩下的同学可以听一下我的理解，其实只看第一段基本上就知道它是干嘛的了。意思是这个字段是记录了list的结构性修改次数（我们可以理解为add，remove这些会改变list大小的操作）。如果是其他方式导致的就回抛出ConcurrentModificationException异常。<br>所以我们再去看看子类的ArrayList的add，remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个是add里面的子方法</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>      modCount++;<br><br>      <span class="hljs-comment">// overflow-conscious code</span><br>      <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>          grow(minCapacity);<br>  &#125;<br><br><span class="hljs-comment">// 这个是remove(int index)</span><br>  <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        rangeCheck(index);<br><br>        modCount++;<br>        <span class="hljs-type">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> elementData(index);<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>            System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                             numMoved);<br>        elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br><br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br><span class="hljs-comment">// 这是remove(Object o)</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fastRemove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>       modCount++;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> size - index - <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">if</span> (numMoved &gt; <span class="hljs-number">0</span>)<br>           System.arraycopy(elementData, index+<span class="hljs-number">1</span>, elementData, index,<br>                            numMoved);<br>       elementData[--size] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>   &#125;    <br></code></pre></td></tr></table></figure><p>看完这几个方法，是不是都看到了modCount++这个操作？是的，添加和删除的时候都会对这个modCount加一。好了，我们在回头看看为啥test4()会抛出异常。<br>首先我们知道list里面add了三个元素所以modCount在添加完元素的时候是3，然后它开始遍历，当发现元素2的时候，去移除了元素2，此时modCount变为4.<br>我们在会到ArrayList的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">forEach</span><span class="hljs-params">(Consumer&lt;? <span class="hljs-built_in">super</span> E&gt; action)</span> &#123;<br>       Objects.requireNonNull(action);<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount;<br>       <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>       <span class="hljs-keyword">final</span> E[] elementData = (E[]) <span class="hljs-built_in">this</span>.elementData;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.size;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123;<br>           action.accept(elementData[i]);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (modCount != expectedModCount) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>可以看到一开始把modCoun赋值给了expectedModCount，然后for循环里面和最后的if条件均对这个modCount有跑断，if里面如果发现modCount和expectedModCount不相等了，就抛出异常。当遍历到元素2，action.accept(elementData[i]);这一行执行完，再去遍历元素3的时候因为modCount &#x3D;&#x3D; expectedModCount不相等了，所以循环推出，因此不会打印出找到元素3了，并且执行到if条件直接抛出异常。</p><h4 id="5-迭代器"><a href="#5-迭代器" class="headerlink" title="5.迭代器"></a>5.迭代器</h4><p>我们在来看看正确的使用方式，使用迭代器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test5</span><span class="hljs-params">()</span> &#123;<br>       Iterator&lt;String&gt; iterator = list.iterator();<br>       <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> iterator.next();<br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素2&quot;</span>.equals(temp)) &#123;<br>               iterator.remove();<br>           &#125;<br><br>           <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;元素3&quot;</span>.equals(temp)) &#123;<br>               System.out.println(<span class="hljs-string">&quot;找到元素3了&quot;</span>);<br>           &#125;<br>       &#125;<br>   &#125;<br>   <span class="hljs-comment">// 这里打印出了 找到元素3了</span><br></code></pre></td></tr></table></figure><p>上面的test3我们已经看到这个迭代器的代码了，那为啥它没问题呢？其实原理非常的沙雕，不信你看！<br><img src="http://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/article_picture/remove%E9%9B%86%E5%90%88%E7%B1%BB%E5%85%83%E7%B4%A0/%E5%A5%87%E6%80%AA%E7%9A%84%E7%9F%A5%E8%AF%86.jfif"><br>这是迭代器的remove方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (lastRet &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>    checkForComodification();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        ArrayList.<span class="hljs-built_in">this</span>.remove(lastRet);<br>        cursor = lastRet;<br>        lastRet = -<span class="hljs-number">1</span>;<br>        expectedModCount = modCount;<br>        <span class="hljs-comment">// 看到没有直接把modeCount重新赋值给了expectedModCount 所以它们一直会相等啊</span><br>    &#125; <span class="hljs-keyword">catch</span> (IndexOutOfBoundsException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以它是可以找到元素3的，因为直接忽略了remove对modCount的影响。</p><h4 id="6-removeIf"><a href="#6-removeIf" class="headerlink" title="6.removeIf"></a>6.removeIf</h4><p>jdk8还出了一种新写法，封装了在遍历元素时删除元素，removeIf(),如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">list.removeIf(item -&gt; <span class="hljs-string">&quot;元素2&quot;</span>.equals(item)<br></code></pre></td></tr></table></figure><p>点进去可以看到代码和上一个差不多只是封装了一层罢了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">default</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeIf</span><span class="hljs-params">(Predicate&lt;? <span class="hljs-built_in">super</span> E&gt; filter)</span> &#123;<br>        Objects.requireNonNull(filter);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> Iterator&lt;E&gt; each = iterator();<br>        <span class="hljs-keyword">while</span> (each.hasNext()) &#123;<br>            <span class="hljs-keyword">if</span> (filter.test(each.next())) &#123;<br>                each.remove();<br>                removed = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> removed;<br>    &#125;<br></code></pre></td></tr></table></figure><p>总结：<br>1.我们探究了好几种遍历时删除元素的方式，也知道了fail-fast的基本概念。<br>2.学会了以后遍历的时候删除元素要使用迭代器哦，而且发现即使是单线程依然可以抛出ConcurrentModificationException<br>3.如果是多线程操作list的话建议使用CopyOnWriteArrayList，或者对迭代器加锁也行，看个人习惯吧~</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/%E5%90%AC%E8%BF%87%E4%BA%86API%E5%92%B1%E4%BB%AC%E6%9D%A5%E7%9C%8B%E7%9C%8BSPI%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2024/08/12/%E5%90%AC%E8%BF%87%E4%BA%86API%E5%92%B1%E4%BB%AC%E6%9D%A5%E7%9C%8B%E7%9C%8BSPI%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h3 id="引语"><a href="#引语" class="headerlink" title="引语"></a>引语</h3><p> 平时API倒是听得很多?SPI又是啥.别急我们来先看看面向接口编程的调用关系，来了解一下，API和SPI的相似和不同之处。</p><h3 id="SPI理解"><a href="#SPI理解" class="headerlink" title="SPI理解"></a>SPI理解</h3><p>先来一段官话的介绍:SPI 全称为 (Service Provider Interface) ，是JDK内置的一种服务提供发现机制.(听了一脸懵逼)好的，我们结合图片来理解一下。<br><img src="http://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/article_picture/%E5%90%AC%E8%BF%87%E4%BA%86API%E5%92%B1%E4%BB%AC%E7%9C%8B%E7%9C%8BSPI%E6%98%AF%E5%95%A5/%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%E5%9B%BE.png"><br>&nbsp;&nbsp;&nbsp;&nbsp;简单的来说分为调用方，接口，服务方.接口就是协议，契约，可以调用方定义，也可以由服务方定义，也就是接口是可以位于调用方的包或者服务方的包.<br>1.接口的定义和实现都在服务方的时候，仅暴露出接口给调用方使用的时候，我们称为API;<br>2.接口的定义在调用方的时候(实现在服务方)，我们给它也取个名字–SPI。<br>应该还比较好理解吧？</p><h3 id="SPI的使用场景"><a href="#SPI的使用场景" class="headerlink" title="SPI的使用场景"></a>SPI的使用场景</h3><p>SPI在框架中其实有很多广泛的应用，这里列举几个例子：<br>1.Mysql驱动的选择driverManager根据配置来确定要使用的驱动;<br>2.dubbo框架中的扩展机制（<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html">dubbo官网链接</a>）</p><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h3><p>看完上面的简介和SPI在框架中的应用，想必对SPI在读者的大脑中已经产生了一个雏形，talk is cheap!show me the code.说了这么多,我们具体写一个简单的例子来看看效果,验证一下SPI.</p><p>1.首先定义一个接口,忍者服务接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">NinjaService</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTask</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>2.接下来写两个实现类,ForbearanceServiceImpl(上忍),ShinobuServiceImpl(下忍)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForbearanceServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NinjaService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTask</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;上忍在执行A级任务&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShinobuServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">NinjaService</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performTask</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;下忍在执行D级任务&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3.接下来我们在main&#x2F;resources&#x2F;下创建META-INF&#x2F;services目录,并且在services目录下创建一个com.scott.java.task.spi.NinjaService(忍者服务类的全限定名)的文件.</p><p>4.创建一个Client场景类来调用看看结果<br><img src="http://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/article_picture/%E5%90%AC%E8%BF%87%E4%BA%86API%E5%92%B1%E4%BB%AC%E7%9C%8B%E7%9C%8BSPI%E6%98%AF%E5%95%A5/client.png"><br>很完美的调用了两个实现类的performTask()方法.</p><p>5.最后贴一下目录结构<br><img src="http://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/article_picture/%E5%90%AC%E8%BF%87%E4%BA%86API%E5%92%B1%E4%BB%AC%E7%9C%8B%E7%9C%8BSPI%E6%98%AF%E5%95%A5/dir.png"><br>附上一波代码例子的地址,在spi里面,<a href="https://github.com/wxwwt/java_practice">git链接</a>;</p><h3 id="SPI源码简单分析"><a href="#SPI源码简单分析" class="headerlink" title="SPI源码简单分析"></a>SPI源码简单分析</h3><p>1.先看下核心类ServiceLoader的定义和属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 继承了Iterable类  遍历的时候使用</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceLoader</span>&lt;S&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;S&gt;<br>&#123;<br>  <span class="hljs-comment">// 这就是为啥需要在META-INF/services/目录下创建服务类的文件</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;META-INF/services/&quot;</span>;<br><br>  <span class="hljs-comment">// 被加载的服务</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;S&gt; service;<br><br>  <span class="hljs-comment">// 类加载器</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader loader;<br><br>  <span class="hljs-comment">// 访问控制类</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AccessControlContext acc;<br><br>  <span class="hljs-comment">// 实现类的缓存 根据初始化的顺序 也就是在/services/文件中的定义顺序来定义的加载顺序</span><br>  <span class="hljs-keyword">private</span> LinkedHashMap&lt;String,S&gt; providers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br><br>  <span class="hljs-comment">// 懒加载iterator</span><br>  <span class="hljs-keyword">private</span> LazyIterator lookupIterator;<br><br></code></pre></td></tr></table></figure><p>2.然后从client开始,然后依次debug进去</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ServiceLoader&lt;NinjaService&gt; ninjaServices = ServiceLoader.load(NinjaService.class);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> &#123;<br>      <span class="hljs-comment">// 获取当前的类加载器 也就是AppClassLoader</span><br>      <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>      <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>  &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service, ClassLoader loader)</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceLoader</span>&lt;&gt;(service, loader);<br>   &#125;<br></code></pre></td></tr></table></figure><p>后面的就省略了,因为这里仅仅就是根据NinjaService初始化的事项,没有什么很难理解的点.</p><p>3.我们在看看具体的调用过程,这里使用的是client对应的class文件,因为增加for(foreach)在java中是个语法糖,实际上编译后是这样的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       ServiceLoader&lt;NinjaService&gt; ninjaServices = ServiceLoader.load(NinjaService.class);<br>      <span class="hljs-comment">// 这里一下其实就是增加for解糖后的代码 有兴趣可以去了解下java的语法糖</span><br>       <span class="hljs-type">Iterator</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> ninjaServices.iterator();<br><br>       <span class="hljs-keyword">while</span>(var2.hasNext()) &#123;<br>           <span class="hljs-type">NinjaService</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> (NinjaService)var2.next();<br>           item.performTask();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure><p>4.随着断点继续走,我们进入到var2.hasNext()的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// knownProviders还没有加载过provider 走下面的分支</span><br>             <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                 <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>             <span class="hljs-keyword">return</span> lookupIterator.hasNext();<br>         &#125;<br></code></pre></td></tr></table></figure><p>这里lookupIterator上面ServiceLoader的属性介绍过,它其实是ServiceLoader中的一个Iterator的内部类。然后调用了内部类Iterator的hasNext()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-comment">//   acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;</span><br>          <span class="hljs-comment">//   ServiceLoader初始化没有设置过securityManager,所以acc是null,进入hasNextService()</span><br>           <span class="hljs-keyword">if</span> (acc == <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">return</span> hasNextService();<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;<br>                   <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> hasNextService(); &#125;<br>               &#125;;<br>               <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>           &#125;<br>       &#125;<br></code></pre></td></tr></table></figure><p>5.hasNextService()分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNextService</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">if</span> (nextName != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (configs == <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">// 这里加载了META-INF/services下的文件 也就是含有两个实现类全限定名的文件</span><br>                   <span class="hljs-type">String</span> <span class="hljs-variable">fullName</span> <span class="hljs-operator">=</span> PREFIX + service.getName();<br>                   <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>                       configs = ClassLoader.getSystemResources(fullName);<br>                   <span class="hljs-keyword">else</span><br>                   <span class="hljs-comment">// 因为loader是不为null 的AppClassLoader</span><br>                       configs = loader.getResources(fullName);<br>               &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>                   fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">while</span> ((pending == <span class="hljs-literal">null</span>) || !pending.hasNext()) &#123;<br>               <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) &#123;<br>                   <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>               &#125;<br>               <span class="hljs-comment">// 这里是将上面加载的文件中的两个实现类的文件</span><br>               pending = parse(service, configs.nextElement());<br>           &#125;<br>           nextName = pending.next();<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br></code></pre></td></tr></table></figure><p>6.继续看到parse方法,这里最后返回的是含有两个全限定类名的Iterator<String>,其实就是把services&#x2F;下的文件内容给加载出来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Iterator&lt;String&gt; <span class="hljs-title function_">parse</span><span class="hljs-params">(Class&lt;?&gt; service, URL u)</span> <span class="hljs-keyword">throws</span> ServiceConfigurationError &#123;<br>   <span class="hljs-type">InputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>   ArrayList&lt;String&gt; names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>   <span class="hljs-keyword">try</span> &#123;<br>       in = u.openStream();<br>       r = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(in, <span class="hljs-string">&quot;utf-8&quot;</span>));<br>       <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>       <span class="hljs-keyword">while</span> ((lc = parseLine(service, u, r, lc, names)) &gt;= <span class="hljs-number">0</span>);<br>   &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>       fail(service, <span class="hljs-string">&quot;Error reading configuration file&quot;</span>, x);<br>   &#125; <span class="hljs-keyword">finally</span> &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) r.close();<br>           <span class="hljs-keyword">if</span> (in != <span class="hljs-literal">null</span>) in.close();<br>       &#125; <span class="hljs-keyword">catch</span> (IOException y) &#123;<br>           fail(service, <span class="hljs-string">&quot;Error closing configuration file&quot;</span>, y);<br>       &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> names.iterator();<br>&#125;<br></code></pre></td></tr></table></figure><p>附带的说一下parseLine(service, u, r, lc, names),检查类名是否符合规范,符合的话添加到Iterator中,到这里var2<br>.hasNext()执行完毕,结果是加载了services下的文件内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">parseLine</span><span class="hljs-params">(Class&lt;?&gt; service, URL u, BufferedReader r, <span class="hljs-type">int</span> lc,</span><br><span class="hljs-params">                         List&lt;String&gt; names)</span><br>       <span class="hljs-keyword">throws</span> IOException, ServiceConfigurationError<br>   &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">ln</span> <span class="hljs-operator">=</span> r.readLine();<br>       <span class="hljs-keyword">if</span> (ln == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>       &#125;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">ci</span> <span class="hljs-operator">=</span> ln.indexOf(<span class="hljs-string">&#x27;#&#x27;</span>);<br>       <span class="hljs-keyword">if</span> (ci &gt;= <span class="hljs-number">0</span>) ln = ln.substring(<span class="hljs-number">0</span>, ci);<br>       ln = ln.trim();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> ln.length();<br>       <span class="hljs-keyword">if</span> (n != <span class="hljs-number">0</span>) &#123;<br>           <span class="hljs-keyword">if</span> ((ln.indexOf(<span class="hljs-string">&#x27; &#x27;</span>) &gt;= <span class="hljs-number">0</span>) || (ln.indexOf(<span class="hljs-string">&#x27;\t&#x27;</span>) &gt;= <span class="hljs-number">0</span>))<br>               fail(service, u, lc, <span class="hljs-string">&quot;Illegal configuration-file syntax&quot;</span>);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">cp</span> <span class="hljs-operator">=</span> ln.codePointAt(<span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">if</span> (!Character.isJavaIdentifierStart(cp))<br>               fail(service, u, lc, <span class="hljs-string">&quot;Illegal provider-class name: &quot;</span> + ln);<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> Character.charCount(cp); i &lt; n; i += Character.charCount(cp)) &#123;<br>               cp = ln.codePointAt(i);<br>               <span class="hljs-keyword">if</span> (!Character.isJavaIdentifierPart(cp) &amp;&amp; (cp != <span class="hljs-string">&#x27;.&#x27;</span>))<br>                   fail(service, u, lc, <span class="hljs-string">&quot;Illegal provider-class name: &quot;</span> + ln);<br>           &#125;<br>           <span class="hljs-keyword">if</span> (!providers.containsKey(ln) &amp;&amp; !names.contains(ln))<br>               names.add(ln);<br>       &#125;<br>       <span class="hljs-keyword">return</span> lc + <span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNextService</span><span class="hljs-params">()</span> &#123;<br>          <span class="hljs-keyword">if</span> (nextName != <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (configs == <span class="hljs-literal">null</span>) &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-type">String</span> <span class="hljs-variable">fullName</span> <span class="hljs-operator">=</span> PREFIX + service.getName();<br>                  <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>                      configs = ClassLoader.getSystemResources(fullName);<br>                  <span class="hljs-keyword">else</span><br>                      configs = loader.getResources(fullName);<br>              &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>                  fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">while</span> ((pending == <span class="hljs-literal">null</span>) || !pending.hasNext()) &#123;<br>              <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) &#123;<br>                  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>              &#125;<br>              pending = parse(service, configs.nextElement());<br>          &#125;<br>          <span class="hljs-comment">// 这里将下一个实现类的名字赋值给了LazyIterator的属性nextName</span><br>          nextName = pending.next();<br>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>      &#125;<br></code></pre></td></tr></table></figure><p>7.接下来执行的是 NinjaService item &#x3D; (NinjaService)var2.next()的next(方法),然后继续debug进去,这里我省略了一些方法的调用,只展示出有用的方法这个是ServiceLoader的内部类LazyIterator的nextService()方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> S <span class="hljs-title function_">nextService</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">if</span> (!hasNextService())<br>               <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>           <span class="hljs-type">String</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> nextName;<br>           nextName = <span class="hljs-literal">null</span>;<br>           Class&lt;?&gt; c = <span class="hljs-literal">null</span>;<br>           <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 这里nextName在上面已经赋值过了 所以反射创建实例</span><br>               c = Class.forName(cn, <span class="hljs-literal">false</span>, loader);<br>           &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException x) &#123;<br>               fail(service,<br>                    <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; not found&quot;</span>);<br>           &#125;<br>           <span class="hljs-comment">// 类型判断</span><br>           <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) &#123;<br>               fail(service,<br>                    <span class="hljs-string">&quot;Provider &quot;</span> + cn  + <span class="hljs-string">&quot; not a subtype&quot;</span>);<br>           &#125;<br>           <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 强转类型</span><br>               <span class="hljs-type">S</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> service.cast(c.newInstance());<br>          <span class="hljs-comment">//  将类添加到ServiceLoader的providers属性中 然后返回</span><br>               providers.put(cn, p);<br>               <span class="hljs-keyword">return</span> p;<br>           &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>               fail(service,<br>                    <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; could not be instantiated&quot;</span>,<br>                    x);<br>           &#125;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();          <span class="hljs-comment">// This cannot happen</span><br>       &#125;<br></code></pre></td></tr></table></figure><p>8.到这里子类的实现类返回,分析就结束了.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>1.了解了什么是SPI；<br>2.SPI和API的简单区别和联系；<br>3.学习了怎么使用SPI来扩展服务；<br>4.分析了ServiceLoader的源码加载过程，这里扯一句，简单的就是META-INF&#x2F;services定义好要实现的接口(文件名)和实现类(文件内容),<br>ServiceLoader加载的时候没有实例化实现类,而是在Iterator遍历的时候去用反射创建了实例.</p><p><strong>觉得写得还行的可以点个赞,关注一波,后面会继续写更好的文章~ XD</strong></p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p>1.<a href="http://cr.openjdk.java.net/~mr/jigsaw/spec/api/java/util/ServiceLoader.html">http://cr.openjdk.java.net/~mr/jigsaw/spec/api/java/util/ServiceLoader.html</a><br>2.<a href="https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html">https://www.cnblogs.com/happyframework/archive/2013/09/17/3325560.html</a><br>3.<a href="http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html">http://dubbo.apache.org/zh-cn/blog/introduction-to-dubbo-spi.html</a><br>4.<a href="https://www.cnblogs.com/googlemeoften/p/5715262.html">https://www.cnblogs.com/googlemeoften/p/5715262.html</a><br>5.<a href="https://zhuanlan.zhihu.com/p/28909673">https://zhuanlan.zhihu.com/p/28909673</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/Arrays.asList%E5%AD%98%E5%9C%A8%E7%9A%84%E5%9D%91/"/>
    <url>/2024/08/12/Arrays.asList%E5%AD%98%E5%9C%A8%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h3 id="引语"><a href="#引语" class="headerlink" title="引语:"></a>引语:</h3><p>阿里巴巴java开发规范说到使用工具类Arrays.asList()方法把数组转换成集合时,不能使用其修改集合相关的方法,它的add&#x2F;remove&#x2F;clear方法会抛出UnsupportedOperationException(),我们来看一下为什么会出现这种情况.</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析:"></a>问题分析:</h3><p>我们做个测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>       List&lt;String&gt; list = Arrays.asList(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>);<br>       <span class="hljs-comment">// list.clear();</span><br>       <span class="hljs-comment">// list.remove(&quot;a&quot;);</span><br>       <span class="hljs-comment">// list.add(&quot;g&quot;);</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>被注释的三行可以分别解开注释,运行后确实出现了规约中所说的异常.我们来看下Arrays.asList()做了什么操作.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">asList</span><span class="hljs-params">(T... a)</span> &#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(a);<br>   &#125;<br></code></pre></td></tr></table></figure><p>看上去是个很正常的方法,然而实际上你点进到ArrayList发现,其实ArrayList并不是我们平时用的ArrayList.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt;<br>       <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RandomAccess</span>, java.io.Serializable<br>   &#123;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2764017481108945198L</span>;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] a;<br><br>       ArrayList(E[] array) &#123;<br>           a = Objects.requireNonNull(array);<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>           <span class="hljs-keyword">return</span> a.length;<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-keyword">public</span> Object[] toArray() &#123;<br>           <span class="hljs-keyword">return</span> a.clone();<br>       &#125;<br><br>       <span class="hljs-meta">@Override</span><br>       <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>       <span class="hljs-keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> size();<br>           <span class="hljs-keyword">if</span> (a.length &lt; size)<br>               <span class="hljs-keyword">return</span> Arrays.copyOf(<span class="hljs-built_in">this</span>.a, size,<br>                                    (Class&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>[]&gt;) a.getClass());<br>           System.arraycopy(<span class="hljs-built_in">this</span>.a, <span class="hljs-number">0</span>, a, <span class="hljs-number">0</span>, size);<br>           <span class="hljs-keyword">if</span> (a.length &gt; size)<br>               a[size] = <span class="hljs-literal">null</span>;<br>           <span class="hljs-keyword">return</span> a;<br>       &#125;<br>       <span class="hljs-comment">// 后面省略了</span><br></code></pre></td></tr></table></figure><p>而是Arrays里面的一个内部类.而且这个内部类没有add,clear,remove方法,所以抛出的异常其实来自于AbstractList.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(<span class="hljs-type">int</span> index, E element)</span> &#123;<br>     <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br> &#125;<br><br> <span class="hljs-keyword">public</span> E <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>点进去就会发现抛出异常的地方,clear底层也会调用到remove所以也会抛出异常.</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>1.Arrays.asList()不要乱用,底层其实还是数组;<br>2.如果使用了Arrays.asList()的话,最好不要使用其集合的操作方法;<br>3. List<String> list &#x3D; new ArrayList&lt;&gt;(Arrays.asList(“a”, “b”, “c”))可以在外面这样包一层真正的ArrayList(数组转集合有很多方式,可以参考<a href="https://stackoverflow.com/questions/157944/create-arraylist-from-array">链接</a>).</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9D%91%E7%82%B9/"/>
    <url>/2024/08/12/ThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E5%9D%91%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal的使用和坑点"><a href="#ThreadLocal的使用和坑点" class="headerlink" title="ThreadLocal的使用和坑点"></a>ThreadLocal的使用和坑点</h3><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><p>ThreadLocal的概念：摘自ThreaLocal的注释</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs perl">This <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">provides</span> <span class="hljs-title">thread</span>-<span class="hljs-title">local</span> <span class="hljs-title">variables</span>.  <span class="hljs-title">These</span> <span class="hljs-title">variables</span> <span class="hljs-title">differ</span> <span class="hljs-title">from</span></span><br><span class="hljs-class"> * <span class="hljs-title">their</span> <span class="hljs-title">normal</span> <span class="hljs-title">counterparts</span> <span class="hljs-title">in</span> <span class="hljs-title">that</span> <span class="hljs-title">each</span> <span class="hljs-title">thread</span> <span class="hljs-title">that</span> <span class="hljs-title">accesses</span> <span class="hljs-title">one</span> (<span class="hljs-title">via</span> <span class="hljs-title">its</span></span><br><span class="hljs-class"> * </span>&#123;<span class="hljs-variable">@code</span> get&#125; <span class="hljs-keyword">or</span> &#123;<span class="hljs-variable">@code</span> set&#125; <span class="hljs-function"><span class="hljs-keyword">method</span>) <span class="hljs-title">has</span> <span class="hljs-title">its</span> <span class="hljs-title">own</span>, <span class="hljs-title">independently</span> <span class="hljs-title">initialized</span></span><br><span class="hljs-function"> * <span class="hljs-title">copy</span> <span class="hljs-title">of</span> <span class="hljs-title">the</span> <span class="hljs-title">variable</span>.  </span>&#123;<span class="hljs-variable">@code</span> ThreadLocal&#125; instances are typically private<br> * static fields in classes that wish to associate <span class="hljs-keyword">state</span> with a thread (e.g.,<br> * a user ID <span class="hljs-keyword">or</span> Transaction ID).<br></code></pre></td></tr></table></figure><p>这段话的大概意思是ThreadLocal是保存的线程的本地变量，访问get&#x2F;set方法都是对线程独立的。<br>大白话就是ThreadLocal是和线程相关的，在一个线程没有结束之前，在任意方法中get&#x2F;set在ThreadLocal中设置的值都是只和当前线程有关。<br>因此呢，ThreadLocal的使用场景也可以推测出来，可以用来在一个线程中传递参数，或者某些情况（比如session，数据库操作句柄）只跟线程相关的时候来使用。</p><h3 id="源码分析："><a href="#源码分析：" class="headerlink" title="源码分析："></a>源码分析：</h3><p>我们接下来在看看源代码中，ThreadLocal是什么样的？<br>简答的贴了一下类和常用的几个方法的源代码（此博客是基于JDK1.8）<br>类定义：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">ThreadLocal</span>&lt;<span class="hljs-symbol">T</span>&gt;<br></code></pre></td></tr></table></figure><p>从类定义上可以看出ThreadLocal是支持泛型的</p><p>ThreadLocalMap:</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadLocalMap</span> </span>&#123;<br>        static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</span> </span>&#123;<br>            <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>            <span class="hljs-type">Object</span> value;<br><br>            <span class="hljs-type">Entry</span>(<span class="hljs-type">ThreadLocal</span>&lt;?&gt; k, <span class="hljs-type">Object</span> v) &#123;<br>                <span class="hljs-keyword">super</span>(k);<br>                value = v;<br>            &#125;<br>        &#125;<br>    <span class="hljs-comment">// 后面代码省略</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里首先我们要看到ThreadLocal中有一个静态类叫做ThreadLocalMap，它里面有一个静态类Entry（可以类比Map中的entry，保存实际的key和value，），ThreadLocalMap其实就是保存了ThreadLocal调用set方法设置的value，key就是ThreadLocal。<br>总结一下就是当我们使用ThreadLocal的set方法时，ThreadLocal为key，保存的泛型对象为value，存到了ThreadLocal的内部类ThreadLocalMap中，然后ThreaLocalMap的键值对实际上是放在静态类Entry里面。这里稍微提一句<br>Entry是继承了WeakReference弱引用，key是被弱引用的构造函数给创建的，value是强引用。（java的四种引用可以参考我之前写的文章<a href="https://juejin.im/post/5cea6cbd6fb9a07ee062f3a7">Java四种引用简介</a>）</p><p>get：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>       <span class="hljs-type">ThreadLocalMap</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> getMap(t);<br>       <span class="hljs-keyword">if</span> (map != <span class="hljs-literal">null</span>) &#123;<br>           ThreadLocalMap.<span class="hljs-type">Entry</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> map.getEntry(<span class="hljs-built_in">this</span>);<br>           <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>               <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>               <span class="hljs-type">T</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> (T)e.value;<br>               <span class="hljs-keyword">return</span> result;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> setInitialValue();<br>   &#125;<br></code></pre></td></tr></table></figure><p>get方法可以看出，会先获取当前线程，然后获取ThreadLocalMap，然后把值从ThreadLocalMap中取出来，如果没有ThreadLocalMap就去调用setInitialValue()设置完初始值，并返回。<br>set：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> <span class="hljs-built_in">set</span>(T value) &#123;<br>      <span class="hljs-keyword">Thread</span> t = <span class="hljs-keyword">Thread</span>.currentThread();<br>      ThreadLocalMap <span class="hljs-built_in">map</span> = getMap(t);<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">map</span> != <span class="hljs-built_in">null</span>)<br>          <span class="hljs-built_in">map</span>.<span class="hljs-built_in">set</span>(this, value);<br>      <span class="hljs-keyword">else</span><br>          createMap(t, value);<br>  &#125;<br></code></pre></td></tr></table></figure><p>set方法根据当前的线程从ThreadLocalMap中取得，没有map就创建一个。thread中的 ThreadLocal.ThreadLocalMap threadLocals变量会指向刚才创建的ThreadLocalMap。</p><h3 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h3><p><strong>1.初始化值</strong><br>这样看下来，应该对ThreadLocal的实现和原理有了一个大概的认识。这里提一句，ThreadLocal直接new出来，然后去get的值是null。某些情况下所有的线程都需要有一个初始化的值，这时候可以重写 protected T initialValue()方法，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">ThreadLocal</span>&lt;<span class="hljs-title class_">String</span>&gt; threadLocal2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;<span class="hljs-title class_">String</span>&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">initialValue</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;override initialValue的初始值&quot;</span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>或者jdk1.8可以使用ThreadLocal.withInitial初始化</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livescript">private <span class="hljs-keyword">static</span> ThreadLocal&lt;<span class="hljs-built_in">String</span>&gt; threadLocal1 = ThreadLocal.withInitial<span class="hljs-function"><span class="hljs-params">(() -&gt; <span class="hljs-string">&quot;withInitial的初始值&quot;</span>)</span>;</span><br></code></pre></td></tr></table></figure><p>这样所有的线程使用ThreadLocal的get都会是相同的一个初始化值。</p><p><strong>2.多个线程有可以相同的值</strong><br>可以使用InheritableThreadLocal，父线程中设置的值，子线程中可以访问到。这个用法和上面差不多就不举例子了，有兴趣的可以自己研究下~</p><h3 id="坑点："><a href="#坑点：" class="headerlink" title="坑点："></a>坑点：</h3><p>1.上面看ThreadLocalMap的时候，咱们知道key是弱引用，gc的时候key会被回收，但是value和ThreadLocalMap的引用不会被回收。如果这种情况的Thread很多，而且一直没有执行完，就可能会出现内存泄漏。<br>2.在使用线程池的时候，当使用ThreadLocal调用set方法后，然后没有调用remove的话，因为线程池的线程是复用的，如果同一个线程再去调用get方法可能拿到的值并不是当时set进去的，导致程序数据异常之类的。尽量用完值后就remove掉。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.ThreadLocal在同一个线程传值，或者只跟线程相关的场景使用<br>2.初始化ThreadLocal的值可以用ThreadLocal.withInitial，或重写initialValue()<br>3.父子线程共享相同的值使用InheritableThreadLocal<br>4.<strong>不管是正常使用还是线程池使用ThreadLocal都一定要使用完就remove，否则会内存泄漏或者数据出错</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <url>/2024/08/12/java%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="引语："><a href="#引语：" class="headerlink" title="引语："></a>引语：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;我们知道java相比C，C++中没有令人头痛的指针，但是却有和指针作用相似的引用对象（Reference），就是常说的引用，比如，Object obj &#x3D; new Object()；这个obj就是引用，它指向的是真正的对象Object的地址，不过今天要说的是java中的四种引用。有人可能比较懵逼，四种引用？是的，从JDK1.2之后，java对引用这块的概念进行了扩充，按照引用的强度分为了四种引用：强引用，软引用，弱引用，虚引用。下面就让我们来看看这四种引用都具体的情况吧。</p><h3 id="1-强引用"><a href="#1-强引用" class="headerlink" title="1.强引用"></a>1.强引用</h3><h4 id="1-1介绍："><a href="#1-1介绍：" class="headerlink" title="1.1介绍："></a>1.1介绍：</h4><p>我们平时代码中使用得最多的引用，对象的类是：StrongReference。就比如上面说的Object obj &#x3D; new Object()；我们再熟悉不过了，作为最强的引用，只要引用还存在着，垃圾收集器就不会将该引用给回收，即使会出现OOM（内存溢出）。就是说这种引用只要引用还一直指向的对象，垃圾收集器是不会去管它的，所以它被称为强引用。不过如果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>obj = <span class="hljs-literal">null</span>;<br></code></pre></td></tr></table></figure><p>obj被赋值为了null，该引用就断了，垃圾收集器会在合适的时候回收改引用的内存。<br>还有一种情况就是obj是成员变量，方法执行完了，obj随着被栈帧被回收了，obj引用也是一起被回收了。强引用的使用就不介绍了，地球人都知道。</p><h3 id="2-软引用"><a href="#2-软引用" class="headerlink" title="2.软引用"></a>2.软引用</h3><h4 id="2-1介绍："><a href="#2-1介绍：" class="headerlink" title="2.1介绍："></a>2.1介绍：</h4><p>软引用是用来描述一些有用但是非必须的对象。对应的类是SoftReference，它被回收的时机是系统内存不足的时候，如果内存足够，它不会被回收，内存不足了，可能会发生OOM了，软引用的对象就会被回收。这样的特性是不是就像缓存？是的，软引用可以用来存放缓存的数据，内存足够的时候一直可以访问，内存不足的时候，需要重新创建或者访问原对象。</p><h4 id="2-2使用："><a href="#2-2使用：" class="headerlink" title="2.2使用："></a>2.2使用：</h4><p>其实不管是软引用，弱引用，还是虚引用，代码中使用方式都是像下面这样，使用对应的Reference将对象放入到构造函数当中，然后使用的地方reference.get()来调用具体对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(obj);<br>softReference.get();<br></code></pre></td></tr></table></figure><p>同时可以使用ReferenceQueue来把引用和引用队列给关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>ReferenceQueue&lt;Object&gt; refQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>SoftReference&lt;Object&gt; softReference = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SoftReference</span>&lt;&gt;(obj, refQueue);<br></code></pre></td></tr></table></figure><p><strong>所谓关联起来，其实就是当引用被回收的时候，会被添加到ReferenceQueue中，使用ReferenceQueue.poll()方法可以返回当前可用的引用，并从队列冲删除</strong>。简单来说就是引用和引用队列关联起来（引用的构造函数传入队列），然后引用被回收的时候会被添加到队列中，然后使用poll()方法可以返回引用。</p><h3 id="3-弱引用"><a href="#3-弱引用" class="headerlink" title="3.弱引用"></a>3.弱引用</h3><h4 id="3-1介绍："><a href="#3-1介绍：" class="headerlink" title="3.1介绍："></a>3.1介绍：</h4><p>虚引用比上面两个引用就更菜了，只要垃圾收集器扫描到了它，被弱引用关联的对象就会被回收。被弱引用关联对象的生命周期其实就是从对象创建到下一次垃圾回收。对应的类是WeakReference。</p><h4 id="3-2使用："><a href="#3-2使用：" class="headerlink" title="3.2使用："></a>3.2使用：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>      <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>      ReferenceQueue&lt;Object&gt; refQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;&gt;();<br>      WeakReference&lt;Object&gt; weakRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(obj, refQueue);<br>      System.out.println(<span class="hljs-string">&quot;引用：&quot;</span> + weakRef.get());<br>      System.out.println(<span class="hljs-string">&quot;队列中的东西：&quot;</span> + refQueue.poll());<br>      <span class="hljs-comment">// 清除强引用, 触发GC</span><br>      obj = <span class="hljs-literal">null</span>;<br>      System.gc();<br>      Thread.sleep(<span class="hljs-number">200</span>);<br>      System.out.println(<span class="hljs-string">&quot;引用：&quot;</span> + weakRef.get());<br>      System.out.println(<span class="hljs-string">&quot;引用加入队列了吗？ &quot;</span> + weakRef.isEnqueued());<br>      System.out.println(<span class="hljs-string">&quot;队列中的东西：&quot;</span> + refQueue.poll());<br>      <span class="hljs-comment">/**</span><br><span class="hljs-comment">       * 输出结果</span><br><span class="hljs-comment">       * 引用：java.lang.Object@7bb11784</span><br><span class="hljs-comment">       * 队列中的东西：null</span><br><span class="hljs-comment">       * 引用：null</span><br><span class="hljs-comment">       * 引用加入队列了吗？ true</span><br><span class="hljs-comment">       * 队列中的东西：java.lang.ref.WeakReference@33a10788</span><br><span class="hljs-comment">       */</span><br>  &#125;<br></code></pre></td></tr></table></figure><p>可以看到当强引用被清除，手动触发GC后，弱引用回收，被加入到队列中了。</p><h4 id="3-3扩展："><a href="#3-3扩展：" class="headerlink" title="3.3扩展："></a>3.3扩展：</h4><p>WeakHashMap跟hashMap很像，差别就在于，当WeakHashMap的key（弱引用），指向的对象被回收了，weakhashMap中的对象也就消失了。不会和HashMap一样一直持有该对象，导致无法回收。<br>不赘述了，有兴趣的可以了解一下，<a href="http://www.importnew.com/23182.html">WeakHashMap</a>。</p><h3 id="4-虚引用"><a href="#4-虚引用" class="headerlink" title="4.虚引用"></a>4.虚引用</h3><h4 id="4-1介绍："><a href="#4-1介绍：" class="headerlink" title="4.1介绍："></a>4.1介绍：</h4><p>虚引用是最弱的一种引用，它不会影响对象的生命周期，对象被回收跟它没啥关系。它引用的对象可以在任何时候被回收，而且也无法根据虚引用来取得一个对象的实例。仅仅当它指向的对象被回收的时候，它会受到一个通知。对应的类是PhantomReference。</p><h4 id="4-2使用："><a href="#4-2使用：" class="headerlink" title="4.2使用："></a>4.2使用：</h4><p>有人就要问既然对对象回收没影响，那它有啥用（其实用处很少），我查阅网上的资料说是，可以用来监控对象的回收，和记录日志。简单点说就是对象被回收的时候，和虚引用相关的队列知道了实例对象被回收了。这个时候我们可以记录下来，知道对象是什么时候被回收的。<br>从而起到监控的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">abc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>       ReferenceQueue&lt;Object&gt; refQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReferenceQueue</span>&lt;Object&gt;();<br>       PhantomReference&lt;Object&gt; abcRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PhantomReference</span>&lt;Object&gt;(abc, refQueue);<br>       System.out.println(<span class="hljs-string">&quot;队列中的东西：&quot;</span> + refQueue.poll());<br>       abc = <span class="hljs-literal">null</span>;<br>       System.gc();<br>       Thread.sleep(<span class="hljs-number">1000</span>);<br>       System.out.println(<span class="hljs-string">&quot;引用加入队列了吗？ &quot;</span> + abcRef.isEnqueued());<br>       System.out.println(<span class="hljs-string">&quot;队列中的东西：&quot;</span> + refQueue.poll());<br>       <span class="hljs-comment">/**</span><br><span class="hljs-comment">        * 输出：</span><br><span class="hljs-comment">        * 队列中的东西：null</span><br><span class="hljs-comment">        * 引用加入队列了吗？ true</span><br><span class="hljs-comment">        * 队列中的东西：java.lang.ref.PhantomReference@7bb11784</span><br><span class="hljs-comment">        */</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>发现队列中有引用了，就可以添加日志记录了。</p><h3 id="5-总结："><a href="#5-总结：" class="headerlink" title="5.总结："></a>5.总结：</h3><p>将人比作垃圾收集器，引用比作食物，我们来总结下四种引用：<br>强引用是毒药，即使你很饿了你也不会去吃它；<br>软引用是零食，不饿的时候不吃，饿了饥不择食，零食也能填饱肚子；<br>弱引用是饭菜，到了吃饭时间（垃圾回收），就吃饭菜；<br>虚引用是剩菜，当你吃完东西（回收完对象），就回剩下剩菜，别人就知道你吃过饭了。</p><h4 id="5-1表格对比："><a href="#5-1表格对比：" class="headerlink" title="5.1表格对比："></a>5.1表格对比：</h4><table><thead><tr><th>引用</th><th>回收时机</th><th>使用场景</th></tr></thead><tbody><tr><td>强</td><td>不会被回收</td><td>正常编码使用</td></tr><tr><td>软</td><td>内存不够了，被GC</td><td>可作为缓存</td></tr><tr><td>弱</td><td>GC发生时</td><td>可作为缓存（WeakHashMap）</td></tr><tr><td>虚</td><td>任何时候</td><td>监控对象回收，记录日志</td></tr></tbody></table><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><p>1.<a href="https://blog.csdn.net/l540675759/article/details/73733763">https://blog.csdn.net/l540675759/article/details/73733763</a><br>2.<a href="https://www.iteye.com/topic/587995">https://www.iteye.com/topic/587995</a><br>3.<a href="https://www.geeksforgeeks.org/types-references-java/">https://www.geeksforgeeks.org/types-references-java/</a><br>4.<a href="https://blog.csdn.net/aitangyong/article/details/39453365">https://blog.csdn.net/aitangyong/article/details/39453365</a>  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2024/08/12/java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="引语"><a href="#引语" class="headerlink" title="引语:"></a>引语:</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;平时我们在运行程序的时候,创建的对象都在内存中,当程序停止或者中断了,对象也就不复存在了.如果我们能将对象保存起来,在需要使用它的时候在拿出来使用就好了,并且对象的信息要和我们保存<br>时的信息一致.序列化就可以解决了这样的问题.序列化当然不止一种方式,如下:</p><table><thead><tr><th align="center">序列类型</th><th align="center">是否跨语言</th><th align="center">优缺点</th></tr></thead><tbody><tr><td align="center">hession</td><td align="center">支持</td><td align="center">跨语言,序列化后体积小,速度较快</td></tr><tr><td align="center">protostuff</td><td align="center">支持</td><td align="center">跨语言,序列化后体积小,速度快,但是需要Schema,可以动态生成</td></tr><tr><td align="center">jackson</td><td align="center">支持</td><td align="center">跨语言,序列化后体积小,速度较快,且具有不确定性</td></tr><tr><td align="center">fastjson</td><td align="center">支持</td><td align="center">跨语言支持较困难,序列化后体积小,速度较快,只支持java,c#</td></tr><tr><td align="center">kryo</td><td align="center">支持</td><td align="center">跨语言支持较困难,序列化后体积小,速度较快</td></tr><tr><td align="center">fst</td><td align="center">不支持</td><td align="center">跨语言支持较困难,序列化后体积小,速度较快，兼容jdk</td></tr><tr><td align="center">jdk</td><td align="center">不支持</td><td align="center">序列化后体积很大,速度快</td></tr></tbody></table><p>我们今天介绍的就是java原生的Serializable序列化.<br>先列一下概念:<br>序列化:序列化是将对象的状态信息转换为可以存储或传输的形式的过程<br>反序列化:从存储或传输形式还原为对象</p><h3 id="Serializable的使用"><a href="#Serializable的使用" class="headerlink" title="Serializable的使用"></a>Serializable的使用</h3><p>序列化使用起来很简单只需要实现Serializable接口即可,然后序列化(序列化是将对象的状态信息转换为可以存储或传输的形式的过程)和反序列化(反之,从存储或传输形式还原为对象).<br>只要使用ObjectOutputStream和ObjectInputStream将对象转为二进制序列和还原为java对象.话不多说,看下代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSerializable</span><span class="hljs-params">(String fileName)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(fileName))) &#123;<br>           <span class="hljs-comment">// &quot;XXX&quot; 的String也可以直接作为对象进行反序列化的</span><br>           objectOutputStream.writeObject(<span class="hljs-string">&quot;test serializable&quot;</span>);<br>           <span class="hljs-type">SerializableData</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SerializableData</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;testStr&quot;</span>);<br>           objectOutputStream.writeObject(data);<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testDeserializable</span><span class="hljs-params">(String fileName)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">objectInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName))) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> (String) objectInputStream.readObject();<br>           System.out.println(<span class="hljs-string">&quot;String的反序列化: &quot;</span> + str);<br>           <span class="hljs-type">SerializableData</span> <span class="hljs-variable">readData</span> <span class="hljs-operator">=</span> (SerializableData) objectInputStream.readObject();<br>           System.out.println(<span class="hljs-string">&quot;反序列化的对象: &quot;</span> + readData.toString());<br>           <span class="hljs-comment">// 输出:反序列化的对象: SerializableData(testInt=1, testStr=testStr)</span><br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">// 使用到的类</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SerializableData</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer testInt;<br><br>    <span class="hljs-keyword">private</span> String testStr;<br>&#125;<br></code></pre></td></tr></table></figure><p>第一个方法是传入文件路径,将String和SerializableData对象序列化到fileName指定的文件中;第二个方法是反序列化将文件中的二进制还原为java对象.<br>这里其实比较简单没有什么大问题,稍微提一句的就是writeObject这个方法是可以直接将”写入的字符串”这种形式的对象直接序列化为二进制的.<br>这里还有一点就是反序列化的版本号必须和原本对象的版本号(private static final long serialVersionUID &#x3D; 1L;这个因为是自己测试所以没有写默认是1L,修改后,反序列化的对象版本号不一致会报错)一致,并且jvm能找到反序列化的文件的位置,否则都会失败.</p><h3 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h3><p>简单的使用序列化和反序列化应该没有什么问题,我们再来看看transient关键字是啥?在某些场景下,我们需要写入或者还原的数据中其实有我们不需要透露或者说不想暴露给外部的数据,如果我们将这些隐私的数据序列化,在反序列化出来,<br>那么这些信息就泄漏了.而transient关键字呢,就是防止这种事情的发生.<br>当属性被加上了transient关键字以后,序列化时不会将该属性的值给写入,所以反序列化的时候我们会发现原本写入的数据,还原出来是null.<br>我们写一个例子看看是否是这样呢?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testTransient</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;transientData.txt&quot;</span>;<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(fileName))) &#123;<br>           <span class="hljs-type">Account</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>           out.writeObject(data);<br>       &#125;<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName))) &#123;<br>           <span class="hljs-type">Account</span> <span class="hljs-variable">readData</span> <span class="hljs-operator">=</span> (Account) in.readObject();<br>           System.out.println(<span class="hljs-string">&quot;transient关键字的对象: &quot;</span> + readData.toString());<br>           <span class="hljs-comment">// 输出: transient关键字的对象: Account(id=1, userName=user1, idCardNumber=null)</span><br>       &#125;<br>   &#125;<br><br><span class="hljs-comment">// 对应的对象</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String idCardNumber;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们有一个Account对象,我们不想暴露出我们的省份证号码idCardNumber,于是乎加上了transient关键字.<br>然后将idCardNumber已经初始化过的data对象序列化,当我们再反序列化去取得这个idCardNumber的值的时候,发现确实对象的idCardNumber是null,transient是起作用的.<br>如果是对基本类型数据加上transitent话,会得到对应的默认值,就好比是int的数据类型,得到的就是0.</p><h3 id="Externalizable的使用"><a href="#Externalizable的使用" class="headerlink" title="Externalizable的使用"></a>Externalizable的使用</h3><p>使用过自动的序列化和反序列化以后,我们又想在序列化和反序列化的时候我们能不能自己控制呢?在序列化和反序列化的时候我们能不能加点日志或者其他的操作之类的呢?<br>是的,阔以的.只需要轻轻一点,实现Externalizable接口即可,和Serializable使用差不多.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testExternalizable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;testExternalizable.txt&quot;</span>;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(fileName))) &#123;<br>            <span class="hljs-type">Account2</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account2</span>(<span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-number">1</span>);<br>            out.writeObject(data);<br>        &#125;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName))) &#123;<br>            <span class="hljs-type">Account2</span> <span class="hljs-variable">readData</span> <span class="hljs-operator">=</span> (Account2) in.readObject();<br>            System.out.println(<span class="hljs-string">&quot;Externalizable的对象: &quot;</span> + readData.toString());<br>        &#125;<br>    &#125;<br><br><span class="hljs-comment">// 使用到的对象</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Externalizable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> String idCardNumber;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeExternal</span><span class="hljs-params">(ObjectOutput out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了writeExternal方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readExternal</span><span class="hljs-params">(ObjectInput in)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了readExternal方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果执行了上面的代码,恭喜你,获得一个Exception的奖励.大概长这样,java.io.InvalidClassException:XXX no valid constructor,<br><strong>Externalizable在执行的时候会调用默认的无参构造函数,而且记住哦,必须是public的</strong>,如果没有加public你会发现又奖励了一个Exception给你.<br>讲道理这个是比较坑的.下面我们来看看正确的用法,序列化和反序列化都是我们自己控制的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testExternalizable</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;testExternalizable.txt&quot;</span>;<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileOutputStream</span>(fileName))) &#123;<br>           <span class="hljs-type">Account3</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Account3</span>(<span class="hljs-string">&quot;user1&quot;</span>, <span class="hljs-number">1</span>);<br>           out.writeObject(data);<br>       &#125;<br>       <span class="hljs-keyword">try</span> (<span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(fileName))) &#123;<br>           <span class="hljs-type">Account3</span> <span class="hljs-variable">readData</span> <span class="hljs-operator">=</span> (Account3) in.readObject();<br>           System.out.println(<span class="hljs-string">&quot;Externalizable的对象: &quot;</span> + readData.toString());<br>           <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 输出:</span><br><span class="hljs-comment">            * 执行了writeExternal方法</span><br><span class="hljs-comment">            * 执行了readExternal方法</span><br><span class="hljs-comment">            * Externalizable的对象: Account3(userName=user1, id=1)</span><br><span class="hljs-comment">            */</span><br>       &#125;<br>   &#125;<br><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Account3</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Externalizable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account3</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Account3</span><span class="hljs-params">(String userName, Integer id)</span> &#123;<br>        <span class="hljs-built_in">this</span>.userName = userName;<br>        <span class="hljs-built_in">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeExternal</span><span class="hljs-params">(ObjectOutput out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了writeExternal方法&quot;</span>);<br>        out.writeObject(userName);<br>        out.writeInt(id);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">readExternal</span><span class="hljs-params">(ObjectInput in)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        System.out.println(<span class="hljs-string">&quot;执行了readExternal方法&quot;</span>);<br>        userName = (String) in.readObject();<br>        id = in.readInt();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>1.我们介绍了jdk自带的序列化和反序列化(和其中的一些坑点);<br>2.知道了transient可以将隐私数据不序列化;<br>3.还有Externalizable可以自己来控制序列化和反序列化的进程.</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料:"></a>参考资料:</h3><p>1.<a href="https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serial-arch.html#a6428(%E5%AE%98%E7%BD%91)">https://docs.oracle.com/javase/8/docs/platform/serialization/spec/serial-arch.html#a6428(官网)</a><br>2.<a href="https://blog.csdn.net/do_bset_yourself/article/details/77173143(%E6%91%98%E5%BD%95%E4%BA%86%E5%90%84%E7%A7%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%96%B9%E5%BC%8F%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9)">https://blog.csdn.net/do_bset_yourself/article/details/77173143(摘录了各种序列化方式的优缺点)</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/java%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <url>/2024/08/12/java%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="java的深拷贝和浅拷贝"><a href="#java的深拷贝和浅拷贝" class="headerlink" title="java的深拷贝和浅拷贝"></a>java的深拷贝和浅拷贝</h3><p>我们知道拷贝就是生成一个新对象和原对象一模一样，但是拷贝也是分方式和程度的，我们来看一下什么是浅拷贝什么是深拷贝</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>在Java中，java.lang.Object类的clone()方法用于克隆（浅拷贝，属性的指向是相同的）。<br>该方法创建一个对象的副本，并通过逐字段分配在其上对其进行调用并返回该对象的引用。<br>要实现浅拷贝需要实现Cloneable接口，该接口里面没有任何方法，它指向的是java.lang.Object类的clone()</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> <span class="hljs-function">Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException</span>;<br></code></pre></td></tr></table></figure><p>它是一个native方法，由C&#x2F;C++实现<br>我们看看例子，理解下它为啥叫浅拷贝<br>首先有一个字典对象类，它实现了序列化（）和克隆的接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dictionary</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializable</span> &#123;<br><br>   <span class="hljs-keyword">private</span> String name;<br><br>   <span class="hljs-keyword">private</span> List&lt;String&gt; words;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>       &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>           e.printStackTrace();<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>   &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shallowCopy</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Dictionary</span> <span class="hljs-variable">dictionary1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dictionary</span>();<br>       dictionary1.setName(<span class="hljs-string">&quot;汉语词典&quot;</span>);<br>       dictionary1.setWords(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;<br>           add(<span class="hljs-string">&quot;你好&quot;</span>);<br>           add(<span class="hljs-string">&quot;浅拷贝&quot;</span>);<br>       &#125;&#125;);<br>       <span class="hljs-type">Dictionary</span> <span class="hljs-variable">dictionary2</span> <span class="hljs-operator">=</span> (Dictionary) dictionary1.clone();<br>       System.out.println(dictionary1 == dictionary2);<br>       dictionary2.getWords().add(<span class="hljs-string">&quot;新词语&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;dictionary1: &quot;</span> + dictionary1.toString());<br>       System.out.println(<span class="hljs-string">&quot;dictionary2: &quot;</span> + dictionary2.toString());<br><br>       dictionary1.setName(<span class="hljs-string">&quot;新名字&quot;</span>);<br>       System.out.println(<span class="hljs-string">&quot;dictionary1: &quot;</span> + dictionary1.toString());<br>       System.out.println(<span class="hljs-string">&quot;dictionary2: &quot;</span> + dictionary2.toString());<br>   &#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-literal">false</span><br>dictionary1: Dictionary<span class="hljs-params">(<span class="hljs-attr">name</span>=汉语词典, <span class="hljs-attr">words</span>=[你好, 浅拷贝, 新词语])</span><br>dictionary2: Dictionary<span class="hljs-params">(<span class="hljs-attr">name</span>=汉语词典, <span class="hljs-attr">words</span>=[你好, 浅拷贝, 新词语])</span><br>dictionary1: Dictionary<span class="hljs-params">(<span class="hljs-attr">name</span>=新名字, <span class="hljs-attr">words</span>=[你好, 浅拷贝, 新词语])</span><br>dictionary2: Dictionary<span class="hljs-params">(<span class="hljs-attr">name</span>=汉语词典, <span class="hljs-attr">words</span>=[你好, 浅拷贝, 新词语])</span><br></code></pre></td></tr></table></figure><p>从结果上我们知道dictionary1，dictionary2不是指向的同一个对象，确实创建了两个对象，但是当第二个对象属性被修改时，第一个对象也跟着变了。<br>验证了我们之前说的浅拷贝，两个对象的属性指向的是堆中相同的对象。</p><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝相对于浅拷贝来说就是属性也是新的对象，我们可以将对象的每一个属性也实现cloneable接口，就可以达到深拷贝的效果。我们也可以使用序列化反序列化来实现深拷贝。<br>首先将Dictionary实现Serializable接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dictionary</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Cloneable</span>, Serializable &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; words;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.clone();<br>        &#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deepCopy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>        <span class="hljs-type">Dictionary</span> <span class="hljs-variable">dictionary1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dictionary</span>();<br>        dictionary1.setName(<span class="hljs-string">&quot;汉语词典&quot;</span>);<br>        dictionary1.setWords(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;() &#123;&#123;<br>            add(<span class="hljs-string">&quot;你好&quot;</span>);<br>            add(<span class="hljs-string">&quot;浅拷贝&quot;</span>);<br>        &#125;&#125;);<br><br>        <span class="hljs-type">Dictionary</span> <span class="hljs-variable">dictionary2</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">byteArrayOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">objectOutputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(byteArrayOutputStream);<br>        objectOutputStream.writeObject(dictionary1);<br><br>        <span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">byteArrayInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(byteArrayOutputStream.toByteArray());<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(byteArrayInputStream);<br>        dictionary2 = (Dictionary) ois.readObject();<br><br>        <span class="hljs-comment">// 测试方法没关闭流 实际项目记得关闭流</span><br>        System.out.println(dictionary1 == dictionary2);<br>        dictionary2.getWords().add(<span class="hljs-string">&quot;新词语&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;dictionary1: &quot;</span> + dictionary1.toString());<br>        System.out.println(<span class="hljs-string">&quot;dictionary2: &quot;</span> + dictionary2.toString());<br>    &#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-literal">false</span><br>dictionary1: Dictionary(name=汉语词典, words=[你好, 深拷贝])<br>dictionary2: Dictionary(name=汉语词典, words=[你好, 深拷贝, 新词语])<br></code></pre></td></tr></table></figure><p>我可以看到不管是对象还是它的属性都是独立的</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/tomcat%E4%B8%ADpost%E8%AF%B7%E6%B1%82%E9%99%90%E5%88%B6%E9%95%BF%E5%BA%A6/"/>
    <url>/2024/08/12/tomcat%E4%B8%ADpost%E8%AF%B7%E6%B1%82%E9%99%90%E5%88%B6%E9%95%BF%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<p>问题分析和解决:<br>有天测试的时候有一个接口,是同一份代码在预发环境上跑的很正常,但是在测试环境传入了两个参数(参数数据很长)后就返回了500错误.试了好几次发现传一个参数时正常,两个参数就报错,感觉很懵逼.(这里我还以为是代码问题,没有往环境问题上想),<br>抓包后发现一个参数的时候发送信息是1024之内,2个参数就超过了1024就报错了.我想难道是服务器限制了请求长度,然后去看了下测试服务器的配置,发下果然有人设置的tomcat接受的请求长度为1024.(真的蛋疼)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">executor</span>=<span class="hljs-string">&quot;tomcatThreadPool&quot;</span>  <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span>  <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span>  <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8443&quot;</span> <span class="hljs-attr">maxPostSize</span>=<span class="hljs-string">&quot;1024&quot;</span>/&gt;</span> <br></code></pre></td></tr></table></figure><p>引用一下tomcat8的官方文档上说的:<br>The maximum size in bytes of the POST which will be handled by the container FORM URL parameter parsing.<br>The limit can be disabled by setting this attribute to a value less than zero. If not specified, this attribute is set to 2097152 (2 megabytes).<br>Note that the FailedRequestFilter can be used to reject requests that exceed this limit.<br>将 maxPostSize设置为-1(小于0,就是不限制post请求长度)就可以了.</p><p>总结:<br>1.其实这是一个很小的问题,生产上一般是不会设置这么小的,但是tomcat8默认是2M,如果真的请求参数超过了这个长度的还是会报错的.<br>ps:以前确实遇到过请求数据超过2M的post请求,也是修改tomcat的配置才可以;</p><p>2.这里历史还有一个小小的坑点就是,就是从tomcat7之后,不限制post请求长度都是小于0就可以了,等于0的话是长度不能超过0,也就是直接拒绝post请求.<br>tomcat6中是 maxPostSize小于等于0都是不限制,所以这个设置还是要先搞清楚自己用的tomcat是什么版本.(不过tomcat6应该没啥人用了吧,我也就简单的提一下罢了)<br><a href="http://tomcat.apache.org/tomcat-6.0-doc/config/http.html">tomcat6文档</a><br><a href="http://tomcat.apache.org/tomcat-7.0-doc/config/http.html">tomcat7文档</a><br><a href="http://tomcat.apache.org/tomcat-8.0-doc/config/http.html">tomcat8文档</a><br><a href="http://tomcat.apache.org/tomcat-8.0-doc/config/http.html">tomcat8.5文档</a><br><a href="http://tomcat.apache.org/tomcat-9.0-doc/config/http.html">tomcat9文档</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/08/12/%E6%99%AE%E9%80%9A%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8spring%E5%AE%B9%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="引语："><a href="#引语：" class="headerlink" title="引语："></a>引语：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;工作中有时候需要在普通的对象中去调用spring管理的对象，但是在普通的java对象直接使用@Autowired或者@Resource的时候会发现被注入的对象是null，会报空指针。我们可以简单的理解为spring是一个公司，它管理的对象就是它的员工，而普通的java对象是其他公司的员工，如果其他公司要找spring公司的员工一起共事没有经过spring公司的同意肯定是不行的。</p><h3 id="解决方式："><a href="#解决方式：" class="headerlink" title="解决方式："></a>解决方式：</h3><p>方法一：如果这个普通对象可以被spring管理的话，最好是直接交给spring管理，这样spring管理的bean中注入其他的bean是没有问题的。</p><p>方法二：当我们的普通对象没有办法交给spring管理的时候，我们可以创建一个公共的springBeanUtil专门为普通对象提供spring的员工（有点像spring公司的外包部门，把对象外包给其他公司使用，哈哈）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringBeanUtil</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ApplicationContextAware</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext context)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        applicationContext = context;<br>    &#125;<br><br>    <span class="hljs-comment">// 这里使用的是根据class类型来获取bean 当然你可以根据名称或者其他之类的方法 主要是有applicationContext你想怎么弄都可以</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getBeanByClass</span><span class="hljs-params">(Class clazz)</span> &#123;<br>        <span class="hljs-keyword">return</span> applicationContext.getBean(clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个util呢，其实就是实现了ApplicationContextAware接口,有小伙伴要问了这个接口是干嘛的？这里给出链接地址，<a href="https://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/context/ApplicationContextAware.html">ApplicationContextAware参考资料</a>。然后我也将文档中的解释给摘录过来了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ApplicationContextAware</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Aware</span><br>Interface to be implemented by any object that wishes to be notified of the ApplicationContext that it runs in.<br>Implementing <span class="hljs-built_in">this</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">makes</span> sense <span class="hljs-keyword">for</span> example when an object <span class="hljs-keyword">requires</span> access to a set of collaborating beans. Note that configuration via bean references is preferable to implementing <span class="hljs-built_in">this</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">just</span> <span class="hljs-keyword">for</span> bean lookup purposes.<br>This <span class="hljs-keyword">interface</span> <span class="hljs-title class_">can</span> also be implemented <span class="hljs-keyword">if</span> an object needs access to file resources, i.e. wants to call getResource, wants to publish an application event, or <span class="hljs-keyword">requires</span> access to the MessageSource. However, it is preferable to implement the more specific ResourceLoaderAware, ApplicationEventPublisherAware or MessageSourceAware <span class="hljs-keyword">interface</span> <span class="hljs-title class_">in</span> such a specific scenario.<br>Note that file resource dependencies can also be exposed as bean properties of type Resource, populated via Strings with automatic type conversion by the bean factory. This removes the need <span class="hljs-keyword">for</span> implementing any callback <span class="hljs-keyword">interface</span> <span class="hljs-title class_">just</span> <span class="hljs-keyword">for</span> the purpose of accessing a specific file resource.<br>ApplicationObjectSupport is a convenience base <span class="hljs-keyword">class</span> <span class="hljs-title class_">for</span> application objects, implementing <span class="hljs-built_in">this</span> interface.<br></code></pre></td></tr></table></figure><p>大概意思就是说只要实现了ApplicationContextAware接口的类，期望被告知当前运行的applicationContext是什么。然后又说了如果是想要获取资源最好是用ResourceLoaderAware, ApplicationEventPublisherAware or MessageSourceAware 这几个接口，最后还来了一句我们知道你们要使用这些接口，所以我们帮你弄了一个实现了这些接口的抽象类ApplicationObjectSupport（在spring-context的jar包中）。这里说得很清楚要使用bean的话，实现ApplicationContextAware，因为我们这里不需要使用静态资源之类的所以我们就不用spring为我们提供的ApplicationObjectSupport了，有兴趣的可以自己研究下。</p><p>我们这里简单的看一下ApplicationContextAware类里面都有啥？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(ApplicationContext applicationContext)</span> <span class="hljs-keyword">throws</span> BeansException;<br></code></pre></td></tr></table></figure><p>发现就一个方法，spring初始化的时候会将当前的applicationContext传给ApplicationContextAware的setApplicationContext方法，所以只要实现类将这个applicationContext拿到了，就可以通过class类型或者class的名称来获取到spring中的bean了。原理其实很简单吧。使用的时候我们可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Test</span> <span class="hljs-variable">test</span> <span class="hljs-operator">=</span> (Test) SpringBeanUtil.getBeanByClass(Test.class);<br></code></pre></td></tr></table></figure><p>来调用spring中的bean。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/08/12/%E6%80%8E%E4%B9%88%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8inputStream/"/>
    <url>/2024/08/12/%E6%80%8E%E4%B9%88%E9%87%8D%E5%A4%8D%E4%BD%BF%E7%94%A8inputStream/</url>
    
    <content type="html"><![CDATA[<h3 id="引语："><a href="#引语：" class="headerlink" title="引语："></a>引语：</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;之前做项目的时候遇到一个问题,就是从网络中读取的图片要上传到oss,而且要对图片进行裁剪和压缩,其中上传和裁剪都要使用到图片的inputStream,<br>又因为inputstream不能重复读,导致裁剪是成功的,而上传是失败的.我们今天就提供两种方法来解决,inputStream不能重复读的问题.</p><h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析:"></a>问题分析:</h3><p>inputStream的内部有个pos指针,当读取的时候指针会不断的移动,当移动到末尾的时候,就无法再次读取了.<br>我们写个简单的例子来看下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试inputStream内容&quot;</span>;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(text.getBytes());<br><span class="hljs-type">byte</span>[] readArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[inputStream.available()];<br><span class="hljs-type">int</span> <span class="hljs-variable">readCount1</span> <span class="hljs-operator">=</span> inputStream.read(readArray);<br>System.out.println(<span class="hljs-string">&quot;读取了&quot;</span> + readCount1 + <span class="hljs-string">&quot;个字节&quot;</span>);<br><br><span class="hljs-type">byte</span>[] readArray2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[inputStream.available()];<br><span class="hljs-type">int</span> <span class="hljs-variable">readCount2</span> <span class="hljs-operator">=</span> inputStream.read(readArray2);<br>System.out.println(<span class="hljs-string">&quot;读取了&quot;</span> + readCount2 + <span class="hljs-string">&quot;个字节&quot;</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  执行结果是</span><br><span class="hljs-comment">*  读取了23个字节</span><br><span class="hljs-comment">*  读取了-1个字节</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure><p>从执行结果可以看出确实inputstream的设计是只能读取一次.<br><strong>注意: 这里稍微提一下inputStream.available()这个方法,本地的文件可以直接知道文件的大小,但是如果是网络中的数据,这个方法最好不要用,因为传输的时候不是连续的,数据的大小会读取不准</strong></p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决:"></a>问题解决:</h3><p>那么我们实际项目中应该怎么解决呢?总不能就真的只使用一次inputSteam吧.我们来看解决方法:<br><strong>方法一</strong>:使用ByteArrayOutputStream来缓存字节,然后每次读取从缓存的ByteArrayOutputStream中拿取.<br>很自然的想到把inputStream的缓存起来(当然不一定说是要放在ByteArrayOutputStream,其他的方式也可以,都是缓存起来的思路,实现方式有很多种,这种比较方便)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试inputStream内容&quot;</span>;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">rawInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(text.getBytes());<br><span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">outputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br><span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-keyword">while</span> ((len = rawInputStream.read(buffer)) &gt; -<span class="hljs-number">1</span>) &#123;<br>    outputStream.write(buffer, <span class="hljs-number">0</span>, len);<br>&#125;<br>outputStream.flush();<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(outputStream.toByteArray());<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">in2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(outputStream.toByteArray());<br><span class="hljs-type">int</span> <span class="hljs-variable">readCount1</span> <span class="hljs-operator">=</span> in1.read(buffer);<br><span class="hljs-type">int</span> <span class="hljs-variable">readCount2</span> <span class="hljs-operator">=</span> in2.read(buffer);<br>System.out.println(<span class="hljs-string">&quot;读取了&quot;</span> + readCount1 + <span class="hljs-string">&quot;个字节&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;读取了&quot;</span> + readCount2 + <span class="hljs-string">&quot;个字节&quot;</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*  执行结果是</span><br><span class="hljs-comment">*  读取了23个字节</span><br><span class="hljs-comment">*  读取了23个字节</span><br><span class="hljs-comment">*</span><br></code></pre></td></tr></table></figure><p>这里是先将inputStream的数据读取到output中,然后要反复使用inputStream中的内容的时候,我们将output中的数据取出(很神奇的设定,output可以反复取,input只能读一次)</p><p><strong>方法二</strong>:其实inputStream中有操作指针的方法,mark和reset,听名字就知道是标记和重置.在使用inputSteam前我们标记下inputStream指针的位置,读取完之后,重置,然后就可以反复使用了.我们看代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;测试inputStream内容&quot;</span>;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">rawInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(text.getBytes());<br><span class="hljs-type">byte</span>[] readArray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">1024</span>];<br>rawInputStream.mark(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">readCount1</span> <span class="hljs-operator">=</span> rawInputStream.read(readArray);<br>rawInputStream.reset();<br><span class="hljs-type">int</span> <span class="hljs-variable">readCount2</span> <span class="hljs-operator">=</span> rawInputStream.read(readArray);<br>System.out.println(<span class="hljs-string">&quot;读取了&quot;</span> + readCount1 + <span class="hljs-string">&quot;个字节&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;读取了&quot;</span> + readCount2 + <span class="hljs-string">&quot;个字节&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h3><p>1.inputStream只能读取一次,也就是说只能调用read()或者其他的带参数的read()方法一次,在下次调用读取出来是-1,做项目的时候不要忘记这一点了,可能会导致有些坑出现;<br>2.可以使用缓存或者mark&#x2F;reset方法来重复使用inputStream,这里要注意的是如果inputStream如果内容很多,缓存不是一个好办法,因为在使用完之前会占用大量的内存(我遇到过这样的,上传很多图片然后还有缓存,导致内存不够就一直fullGC,然后cpu先爆了);<br>3.还有一个小点就是别忘了关闭使用完的inputStream&#x2F;outputSteam.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/06/29/%E5%BF%8D%E6%B3%95%EF%BC%9A%E5%A3%B0%E9%9F%B3%E5%85%8B%E9%9A%86%E4%B9%8B%E6%9C%AF-GPT-sovits/"/>
    <url>/2024/06/29/%E5%BF%8D%E6%B3%95%EF%BC%9A%E5%A3%B0%E9%9F%B3%E5%85%8B%E9%9A%86%E4%B9%8B%E6%9C%AF-GPT-sovits/</url>
    
    <content type="html"><![CDATA[<p>声音克隆</p><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>最近因为一直在给肚子里面的宝宝做故事胎教，每天（其实是看自己心情抽空讲下故事）都要给宝宝讲故事，心想反正宝宝也看不见我，只听我的声音，干脆偷个懒，克隆自己的声音，然后把故事输入进去。然后老婆想给宝宝做胎教的时候就可以输入一个故事，即使我还没下班也可以给宝宝讲故事，岂不美哉！果然，偷懒是人类进步的阶梯，说干就干。我找了一圈相应的软件，发现GPT-sovits非常符合我的需求，又是开源的，又不需要很长时间的音频素材，简直完美，所以就有了下面的GPT-vosits使用教程。其实网上已经有很多这样的教程了，大家都可以搜一搜，我也只是记录一下自己的使用过程，顺便水（记录）一篇博客，好久没写了，感觉还是的写一写，要不然真的是浪费了自己空闲时间。</p><h1 id="使用："><a href="#使用：" class="headerlink" title="使用："></a>使用：</h1><h2 id="前置条件："><a href="#前置条件：" class="headerlink" title="前置条件："></a>前置条件：</h2><h3 id="测试通过的环境"><a href="#测试通过的环境" class="headerlink" title="测试通过的环境"></a>测试通过的环境</h3><p>下面这个摘自官网，需要用python环境，最好是有一张好的显卡，没有的话cpu其实也可以跑，就是慢嘛。</p><ul><li>Python 3.9，PyTorch 2.0.1，CUDA 11</li><li>Python 3.10.13，PyTorch 2.1.2，CUDA 12.3</li><li>Python 3.9，Pytorch 2.2.2，macOS 14.4.1（Apple 芯片）</li><li>Python 3.9，PyTorch 2.2.2，CPU 设备</li></ul><p><em>注: numba&#x3D;&#x3D;0.56.4 需要 python&lt;3.11</em></p><p>因为我这个纯粹是给自己使用，也就没有折腾在云上，或者服务器上的使用操作了。只有windows电脑的使用步骤，如果各位读者是会点编程，有技术背景的话，可以看下最底部的参考资料，里面有官网的语雀文档，里面有介绍怎么在云上使用，linux，macOS使用等情况。</p><p>1.从官网下载</p><p>官网上提供了两个整合包，<a href="https://huggingface.co/lj1995/GPT-SoVITS-windows-package/resolve/main/GPT-SoVITS-beta-fast-inference-branch.7z?download=true">0206fix3 整合包</a>或<a href="https://huggingface.co/lj1995/GPT-SoVITS-windows-package/resolve/main/GPT-SoVITS-beta0217fix2.7z?download=true">0217fix2 整合包</a>，但是都是huggingface（国外的）下载会很慢。</p><p>还有一个方式就是去B站关注下up主：花儿不哭，自动回复消息里面会有连接。这里我提供了花儿不哭大佬给的网盘地址，<a href="https://pan.baidu.com/s/1OE5qL0KreO-ASHwm6Zl9gA?pwd=mqpi">下载地址</a>，不过还是建议各位去关注一下一键三连，为大佬的开源精神支持一下。</p><p>2.下载完之后，解压7z格式的文件</p><p>3.双击go-webui.bat</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630145807703.png" alt="image-20240630145807703"></p><p>4.语音处理</p><p>如果你的音频素材，很干净，比如说就是你手机录的你自己的声音，那可以跳过这一步。</p><p>如果你的素材是从网上下载过来的，里面有背景声音，杂音等，那就需要走这一步，这样分离出来的声音效果更好，后续输出声音才会更加准确。</p><p>4.1</p><p>我这里是从网上下载的一个海绵宝宝的声音素材，里面有背景音，所以我需要先处理下音频文件，勾选是否开启UVR5-WebUI的勾选框，会弹出来一个新的界面。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630152657725.png" alt="image-20240630152657725"></p><p>4.2 </p><p>参考下面的图，把音频文件放到某个目录，举例，我这里把海绵宝宝的声音放到E:\video\haimianbaobao里面，</p><p>然后在下面的第一个红框里面填入文件系统的地址。红框下面那个是可以直接拖入文件的，也可以用下面那个。</p><p>接着，填写输出__主人声的文件夹__，比如我的音频文件里面不是有海绵宝宝的声音和背景音吗，海绵宝宝的声音就是主人声，其他的声音都是用不到的，就填写在__非主人声文件夹__里面。这里我特意区分了一下，写了一个vocal（主人声）和others（非主人声）的路径，这个路径不存在也没关系，点击转换之后软件会自动创建文件夹。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630153511899.png" alt="image-20240630153511899"></p><p>5.语音切分</p><p>因为这个语音很长的话，训练效果会很差，所以需要将长的语音切短。不过我们这里用的声音其实挺短的，只有10秒，所以只切出来一个文件，如果是比较完整的素材效果会更加好，官网是这么说的如果你的显卡有24G显存，那么高于24秒的音频就要去掉，可以参考一下，看看自己的电脑配置去掉过长的音频。将上一步处理完的音频文件&#x2F;文件夹地址粘贴过来放到第一个红框里面，然后第二个红框加上&#x2F;haimianbaobao方便和其他音频文件区分开。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630154228894.png" alt="image-20240630154228894"></p><p>6.语音降噪</p><p>官网说这个功能不太好用，慎用，所以我们就不用这个功能了，直接跳过</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630154547313.png" alt="image-20240630154547313"></p><p>7.语音打标</p><p>输入上一步得到的文件夹地址，然后填入输出文件夹路径，我们依然是加一个haimianbaobao的文件夹</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630155650498.png" alt="image-20240630155650498"></p><p>8.校对标注</p><p>一般这个标注都是准的，可能有些多音字，或者词语可能会标错之类的，填写好标注文件的地址，开启标注WebUI进行修改调整。我们这里就一句话，也没啥好调的直接跳过了</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630160005789.png" alt="image-20240630160005789"></p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630155920374.png" alt="image-20240630155920374"></p><p>9.训练模型</p><p>切换到第二个TTS的界面，填入标注文件地址，切分文件目录，在点击一键三连即可。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630160719288.png" alt="image-20240630160719288"></p><p>10.微调训练</p><p>微调训练反正根据自己的显卡来，我这里是一张8G的4060，batch_size都选的2，两个训练，SoVITS，GPT依次训练过来。训练轮次在显卡显存不太大的时候也调小一点。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630161743646.png" alt="image-20240630161743646"></p><p>11.推理</p><p>以上的步骤都弄完了，恭喜你，已经可以愉快的玩耍了。</p><p>点到推理的栏目，选择自己之前训练的模型，你可能会看到haimianbaobao的模型有好几个，还有类似e10这样的后缀，表示它的训练轮次，你可以几个模型都试一下哪个效果最好，就用哪个。<img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630170117469.png" alt="image-20240630170117469"></p><p>如果没有看到你训练的模型，点击刷新模型路径试试。</p><p>之后再勾选开启TTS推理WebUI，跳转到一个新的界面，然后在输入一段3-10秒参考音频，我们就从切分好的音频文件夹&#x2F;slicer_opt&#x2F;haimianbaobao里面选一个长度符合的即可。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240630171959213.png" alt="image-20240630171959213"></p><p>接着在输入你想要朗读的文本，点击推理，就会生成一个音频文件，就可以听到你训练的声音读的文本啦~</p><p>如果你的文本很长，下面还会有一个辅助长文本切分的工具，可以按照好几种方式切分，然后把在切分好的文本放入到要合成的文本里面。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>训练了自己的声音，以为可以偷懒用软件替代自己给宝宝讲故事了，结果老婆嫌弃软件没有我讲的声情并茂，也没用几次，还是要我自己讲故事。呜呼，白搞。整体从训练过程来看还是比较麻烦的，对于有技术背景的人可能还好，对于小白来说还是比较复杂的，参考资料里面有个UP主对GPT-SoVITs的流程进行了简化，有兴趣的也可以看看。</p><h1 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h1><p><a href="https://www.descript.com/blog/article/best-ai-voice-cloning-tools">1.最好的AI声音克隆工具</a></p><p><a href="https://www.bilibili.com/video/BV12g4y1m7Uw/?vd_source=789e3d87ea4eb7ba245bd791f41f8e1f">2.花儿不哭B站视频</a></p><p><a href="https://www.bilibili.com/video/BV1P541117yn/?spm_id_from=333.337.search-card.all.click&;vd_source=4d7819b82193f7361a8b1753733c9e13&vd_source=789e3d87ea4eb7ba245bd791f41f8e1f">3.B站视频教程</a></p><p><a href="https://www.yuque.com/baicaigongchang1145haoyuangong/ib3g1e">4.GPT-SoVITS官网语雀文档</a></p><p><a href="https://www.bilibili.com/video/BV1WC411W79t/?spm_id_from=333.788&vd_source=789e3d87ea4eb7ba245bd791f41f8e1f">5.基于GPT-SoVITS修改的更加简洁的一键脚本</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/05/05/%E5%9F%BA%E4%BA%8ELangChain%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAagent/"/>
    <url>/2024/05/05/%E5%9F%BA%E4%BA%8ELangChain%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAagent/</url>
    
    <content type="html"><![CDATA[<p>基于LangChain搭建一个agent</p><p>1.简单介绍下LangChain</p><p>模块划分</p><p>2.介绍下agent</p><p>3.举例说明没有agent之前，大模型无法获得最新的信息</p><p>4.在写怎么构建一个agent的过程</p><p>5.最后展示有了agent之后，大模型的新的效果</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/23/LangChain-Chatchat%E7%9F%A5%E8%AF%86%E5%BA%93%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/03/23/LangChain-Chatchat%E7%9F%A5%E8%AF%86%E5%BA%93%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>LangChain-Chatchat知识库使用</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上次我们完成了Chatchat的本地部署，使用了LLM对话的功能。这次我们尝试一下其他的功能，之前总是有报错没有跑通，这次处理了几个问题之后才跑通了知识库对话和文件对话。</p><h1 id="知识库对话"><a href="#知识库对话" class="headerlink" title="知识库对话"></a>知识库对话</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理:"></a>原理:</h2><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240324115000845.png" alt="image-20240324115000845"></p><p>首先我们看这个图可以明白，知识库对话是有很多步骤的，1-7步是把上传的文件做处理，拆分，转为向量储存起来。然后当我们发起查询请求，也会被转换为向量，接着和向量数据库的向量做相似度比较，找到比较相近的向量对应的文本。最后根据这些文本去构造了prompt请求LLM获取返回数据。</p><h2 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h2><p>先说明一下这里我用的是智谱AI的API，也就是在线的LLM，本地如果是使用chatglm的话，因为本身个人电脑配置不高，所以能运行的模型参数都相对较小，有些知识库对应的信息可能查不出来，用知识库对话的话建议是使用在线的llm。一开始用本地的llm，问了很多知识库的问题都回答不上来，找不到知识库匹配结果，我还以为是我哪里运行有问题，后来换成在线的llm就可以了。</p><p>1.点击知识库管理</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240324171928214.png" alt="image-20240324171928214"></p><p>2.选择或者新建一个知识库</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240324175415611.png" alt="image-20240324175415611"></p><p>这里面有一些向量数据库和Embedding模型可以选择，我就用的默认的，其他的能不能组合跑起来还没有试过。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240324192802019.png" alt="image-20240324192802019"></p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240324192907295.png" alt="image-20240324192907295"></p><p>3.上传知识库文件</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240324175504045.png" alt="image-20240324175504045"></p><p>这个是github上写的支持的文件格式：</p><p>Langchain 应用</p><p>本地数据接入接入非结构化文档</p><ul><li>.txt, .rtf, .epub, .srt</li><li>.eml, .msg</li><li>.html, .xml, .toml, .mhtml</li><li>.json, .jsonl</li><li>.md, .rst</li><li>.docx, .doc, .pptx, .ppt, .odt</li><li>.enex</li><li>.pdf</li><li>.jpg, .jpeg, .png, .bmp</li><li>.py, .ipynb</li></ul><p>4.添加文件到知识库中</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240324175654791.png" alt="image-20240324175654791"></p><p>点击添加文件到知识库，就会把文件保存到知识库，然后裁剪拆分成向量，往向量库放一份当前文本对应的向量。</p><p>这里可以根据文档的具体数据类型来调整，每一段文本的长度。相邻文本重合长度是指的两个文本会重叠的部分，举个例子按照文本250字符切分的话，可能会把一句正常的话给截断掉，所以会多选择一些字符串。</p><p>比如说上面的设置是<code>chunk_size=250</code>, <code>chunk_overlap=50</code>。</p><p>处理文本时,每个文本块的实际长度是 <code>chunk_size</code>&#x3D;250 个字符。</p><p>但是,由于<code>chunk_overlap=50</code>,相邻文本块之间会有 50 个字符的重叠。</p><p>这意味着:</p><ol><li>第一个文本块长度是 250</li><li>第二个文本块从第一个块的第 201 个字符(250-50&#x3D;200,+1&#x3D;201)开始,长度还是 250</li><li>第三个文本块从第二个块的第 201 个字符开始,长度还是 250</li><li>以此类推</li></ol><p>5.展示结果</p><p>这个知识库我传了一本关于黑天鹅事件的pdf，从图中可以看到上面是没有知识库匹配的时候，llm以为我问的是黑天鹅这个物种。下面选择了知识库问答之后，返回的事对黑天鹅事件的描述，对于问问题的人来说，如果一开始就知道要从哪些文档里面去找答案的话，用知识库匹配会更加贴近你想要问的问题。我的理解是，知识库问答在llm问答之前相当于是做了一层预处理，帮助我们构建了更加合理的prompt，所以得到的答案会更加准确，本质上还是llm的能力。因为如果llm本身没有黑天鹅这个知识，它也没法回答我，所以要想好好利用llm的能力，实际上是要构建最合适的问题，这也就是所谓的prompt工程吧。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240324115519420.png" alt="image-20240324115519420"></p><h1 id="文件对话"><a href="#文件对话" class="headerlink" title="文件对话"></a>文件对话</h1><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240323205546051.png" alt="image-20240323205546051"></p><p>文件对话就不多说了，相当于只有搜索向量库，而没有llm优化后回答得部分，东西是能搜索出的。如果是对于有大量数据文档的话，这个向量搜索还是有用的，可以帮助检索提升效率。因为很多时候问问题的人并不是那么的专业，可能问题本身就会会跑偏，直接文本匹配的话，不一定是找到有用的信息。向量搜索能更好地匹配语义相关的结果，可以返回表达类似含义但用词不同的文档，这就是它的优势所在。</p><h1 id="遇到问题"><a href="#遇到问题" class="headerlink" title="遇到问题"></a>遇到问题</h1><p>1.上传文件的时候报错utils.py[line:377] - ERROR: ImportError: 从文件 test&#x2F;test.txt 加载文档时出错：libGL.so.1: cannot open shared object file: No such file or directory</p><p>首先我使用的是pdf，报了这个错，我以为是pdf不能识别的问题。然后就按照chatchat的github的wiki里面对文件进行预处理。修改成了比较简单内容，而且是txt格式方便程序来识别。结果还是报错，就查了下这个报错。发现问题是因为少了系统包下面是gpt对这两个包的说明，反正就是会用的的库吧。</p><p>libgl1-mesa-glx 和 libglib2.0-0 是两个非常重要的库文件:</p><ol><li>libgl1-mesa-glx 这个包提供了Mesa 3D图形库的OpenGL实现。OpenGL(OpenGL Library)是一个跨语言、跨平台的2D和3D图形API,被广泛应用于图形渲染、游戏开发、CAD、虚拟现实、科学可视化等领域。Mesa是一个开源的OpenGL实现,用于在Linux、Windows、macOS等操作系统上提供硬件3D加速支持。libgl1-mesa-glx是Mesa的GLX实现,用于在X Window系统上运行OpenGL程序。</li><li>libglib2.0-0<br>这个包含有GLib库的核心文件。GLib是GNOME项目的底层系统库,提供了基本的系统独立型数据结构和操作,如链表、树、哈希表、内存分配等。它被广泛用作GTK+、GStreamer、WebKitGTK+等GNOME软件的基础构件。GLib提供了线程抽象、IPC、事件循环、Unicode处理等通用功能,是编写应用程序的基础,也可以单独使用。</li></ol><p>总的来说,libgl1-mesa-glx提供OpenGL 3D图形渲染支持,而libglib2.0-0则是编写GTK+&#x2F;GNOME应用程序及其它应用的核心基础库。这两个库在图形界面应用、游戏、科学计算等领域都有重要应用。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/chatchat-space/Langchain-Chatchat/issues/1783">1.pdf文件导入向量库失败</a></p><p><a href="https://github.com/chatchat-space/Langchain-Chatchat/wiki">2.Chatchat的wiki</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/03/03/Langchain-Chatchat%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/03/03/Langchain-Chatchat%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>Langchain-Chatchat安装使用</p><h1 id="1-前言："><a href="#1-前言：" class="headerlink" title="1.前言："></a>1.前言：</h1><p>最近AI爆发式的火，忆往昔尤记得16,17那会移动互联网是特别火热的，也造富了一批公司和个人，出来了很多精妙的app应用。现在轮到AI发力了，想想自己也应该参与到这场时代的浪潮之中，所以就找了开源的项目来玩一玩，学习下里面的知识。不管最后结果有没有造富自己，学到的知识总是有用的，至少不会让自己在AI时代掉队。</p><p>今天要讲的是LangChain-chatchat， 用官网自己的话来说就是： 基于 Langchain 与 ChatGLM 等大语言模型的本地知识库问答应用实现。 一种利用 <a href="https://github.com/hwchase17/langchain">langchain</a> 思想实现的基于本地知识库的问答应用，目标期望建立一套对中文场景与开源模型支持友好、可离线运行的知识库问答解决方案。</p><p>界面如下：</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310194452916.png" alt="image-20240310194452916"></p><h1 id="2-安装步骤："><a href="#2-安装步骤：" class="headerlink" title="2.安装步骤："></a>2.安装步骤：</h1><p>官网有三种安装方式：</p><p>1.autoDL</p><p>2.docker</p><p>3.本地部署</p><p>第一种其实比较方便和实惠，机器配置不够也可以跑模型，每个小时几块钱，而且都是autoDL有对应的镜像可以直接运行，非常的便捷。</p><p>第二种大概有40G的包，部署也算比较方便。</p><p>今天我们讲的是第三种本地部署，虽然比较麻烦，但是在自己机器上部署方便调试，也更容易去了解整个项目是怎么运行的，对于学习来说是比较好的。</p><h2 id="2-1-前置条件"><a href="#2-1-前置条件" class="headerlink" title="2.1 前置条件"></a>2.1 前置条件</h2><h3 id="硬件："><a href="#硬件：" class="headerlink" title="硬件："></a>硬件：</h3><ul><li><p>官网推荐：</p><ul><li><p>本框架使用 <code>fschat</code>驱动，统一使用 <code>huggingface</code>进行推理，其他推理方式(如 <code>llama-cpp</code>，<code>TensorRT加速引擎</code> 建议通过推理引擎以 API 形式接入我们的框架)。</p><p>同时, 我们没有对 <code>Int4</code> 模型进行适配，不保证<code>Int4</code>模型能够正常运行。因此，量化版本暂时需要由开发者自行适配, 我们可能在未来放。</p><p>如果想要顺利在GPU运行本地模型的 <strong>FP16</strong> 版本，你至少需要以下的硬件配置，来保证在我们框架下能够实现 <strong>稳定连续对话</strong></p><ul><li>ChatGLM3-6B &amp; LLaMA-7B-Chat 等 7B模型<ul><li>最低显存要求: 14GB</li><li>推荐显卡: RTX 4080</li></ul></li><li>Qwen-14B-Chat 等 14B模型<ul><li>最低显存要求: 30GB</li><li>推荐显卡: V100</li></ul></li><li>Yi-34B-Chat 等 34B模型<ul><li>最低显存要求: 69GB</li><li>推荐显卡: A100</li></ul></li><li>Qwen-72B-Chat 等 72B模型<ul><li>最低显存要求: 145GB</li><li>推荐显卡：多卡 A100 以上</li></ul></li></ul><p>一种简单的估算方式为：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FP16</span>: 显存占用(GB) = 模型量级 x <span class="hljs-number">2</span><br><span class="hljs-attribute">Int4</span>: 显存占用(GB) = 模型量级 x <span class="hljs-number">0</span>.<span class="hljs-number">75</span><br></code></pre></td></tr></table></figure><p>以上数据仅为估算，实际情况以 <strong>nvidia-smi</strong> 占用为准。 请注意，如果使用最低配置，仅能保证代码能够运行，但运行速度较慢，体验不佳。</p><p>同时，Embedding 模型将会占用 1-2G 的显存，历史记录最多会占用 数GB 的显存，因此，需要多冗余一些显存。</p><p>内存最低要求: 内存要求至少应该比模型运行的显存大。</p><p>例如，运行ChatGLM3-6B <code>FP16</code> 模型，显存占用13G，推荐使用16G以上内存。</p><h3 id="部分测试用机配置参考，在以下机器下开发组成员已经进行原生模拟测试（创建新环境并根据要求下载后运行），确保能流畅运行全部功能的代码框架。"><a href="#部分测试用机配置参考，在以下机器下开发组成员已经进行原生模拟测试（创建新环境并根据要求下载后运行），确保能流畅运行全部功能的代码框架。" class="headerlink" title="部分测试用机配置参考，在以下机器下开发组成员已经进行原生模拟测试（创建新环境并根据要求下载后运行），确保能流畅运行全部功能的代码框架。"></a>部分测试用机配置参考，在以下机器下开发组成员已经进行原生模拟测试（创建新环境并根据要求下载后运行），确保能流畅运行全部功能的代码框架。</h3><ul><li>服务器</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">处理器: Intel® Xeon® Platinum 8558P Processor (260M Cache, 2.7 GHz)</span><br><span class="hljs-section">内存: 4 TB</span><br><span class="hljs-section">显卡组:  NVIDIA H800 SXM5 80GB x 8</span><br><span class="hljs-section">硬盘: 6 PB </span><br><span class="hljs-section">操作系统: Ubuntu 22.04 LTS,Linux kernel 5.15.0-60-generic</span><br><span class="hljs-section">显卡驱动版本: 535.129.03</span><br><span class="hljs-section">Cuda版本: 12.1 </span><br><span class="hljs-section">Python版本: 3.11.7</span><br>网络IP地址：美国，洛杉矶<br></code></pre></td></tr></table></figure><ul><li>个人PC</li></ul><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">处理器: Intel® Core™ i9 processor 14900K </span><br><span class="hljs-section">内存: 256 GB DDR5</span><br><span class="hljs-section">显卡组:  NVIDIA RTX4090 X 1 / NVIDIA RTXA6000 X 1</span><br><span class="hljs-section">硬盘: 1 TB</span><br><span class="hljs-section">操作系统: Ubuntu 22.04 LTS / Arch Linux, Linux Kernel 6.6.7</span><br><span class="hljs-section">显卡驱动版本: 545.29.06</span><br><span class="hljs-section">Cuda版本: 12.3 Update 1</span><br><span class="hljs-section">Python版本: 3.11.7</span><br>网络IP地址：中国，上海 <br></code></pre></td></tr></table></figure></li></ul></li><li><p>我的电脑：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">处理器: 13th Gen Intel(R) Core(TM) i5-13490F</span><br><span class="hljs-section">内存: 32GB DDR5</span><br><span class="hljs-section">显卡组:  NVIDIA RTX4060</span><br><span class="hljs-section">硬盘: 2TB</span><br><span class="hljs-section">操作系统: windows wsl2安装的Ubuntu 22.04.3 LTS</span><br><span class="hljs-section">显卡驱动版本: 536.67</span><br><span class="hljs-section">Cuda版本: 12.2</span><br><span class="hljs-section">Python版本: 3.10.12</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="软件："><a href="#软件：" class="headerlink" title="软件："></a>软件：</h3><ul><li><p>官网推荐：</p><p>要顺利运行本代码，请按照以下系统要求进行配置</p><p><strong>已经测试过的系统</strong></p><ul><li>Linux Ubuntu 22.04.5 kernel version 6.7</li></ul><p>其他系统可能出现系统兼容性问题。</p><p><strong>最低要求</strong></p><p>该要求仅针对标准模式，轻量模式使用在线模型，不需要安装torch等库，也不需要显卡即可运行。</p><ul><li>Python 版本: &gt;&#x3D; 3.8(很不稳定), &lt; 3.12</li><li>CUDA 版本: &gt;&#x3D; 12.1</li></ul><p><strong>推荐要求</strong></p><p>开发者在以下环境下进行代码调试，在该环境下能够避免最多环境问题。</p><ul><li><p>Python 版本 &#x3D;&#x3D; 3.11.7</p></li><li><p>CUDA 版本: &#x3D;&#x3D; 12.1</p></li></ul></li><li><p>笔者电脑：</p><ul><li>系统：windows wsl2安装的Ubuntu 22.04.3 LTS</li><li>python版本:  3.10.12</li><li>CUDA版本：12.2</li></ul></li></ul><p>之所以提一下电脑硬件软件的配置，因为可能存在刚好有读者跟我的差不太多的硬件配置，或者比我好的硬件配置就是可以跑起来的。而且软件这个我可以跑起来的话，也验证了在我这个系统，python版本，CUDA版本的组合是可以运行起来的，也可以给别人一个参考。要注意一点的就是，如果你跟我一样的是使用windows的系统，然后wsl走的linux系统，提一嘴就是windows上安装的cuda版本可能会跟linux系统的cuda版本不一样的情况，最后是卸载掉弄成一样的，小于11.7的话跑通义千问的模型会有问题，虽然我跑通义千问的模型还没有成功，但是在解决一个安装qwen模型的时候遇到一个问题就是安装某个依赖库的时候要求cuda版本大于11.7。</p><h2 id="2-2-部署步骤"><a href="#2-2-部署步骤" class="headerlink" title="2.2 部署步骤"></a>2.2 部署步骤</h2><ul><li><p>拉取代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">拉取仓库</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> --recursive https://github.com/chatchat-space/Langchain-Chatchat.git</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">进入目录</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> Langchain-Chatchat</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装全部依赖</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">pip install -r requirements.txt</span><br></code></pre></td></tr></table></figure></li><li><p>下载模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装模型，这一步如果没有进行，启动项目的时候回自动从https://huggingface.co/上面下载，不过问题就是</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">国内从https://huggingface.co/上下载模型是很慢的。所以建议先从modelscope（魔塔上下载模型），然后在</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">项目的configs/model_config.py填写好MODEL_ROOT_PATH地址，这样不用从外部下载模型直接跑对于第一次运</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">行会快很多。</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载模型,下载模型需要先安装Git LFS，然后运行。官网使用的是https://huggingface.co的包，我这里修</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">改成魔塔的仓库地址了。不过要提一点的是虽然官网要你下载了这两个模型，如果没有修改配置文件里面的话，跑</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">起来用的并不这两个模型。chatglm2-6b这个是llm（大语言模型），m3e-base这个是embeding模型。需要在</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git lfs install</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://www.modelscope.cn/ZhipuAI/chatglm2-6b.git</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">git <span class="hljs-built_in">clone</span> https://www.modelscope.cn/Jerry0/m3e-base.git</span><br></code></pre></td></tr></table></figure><ul><li>配置模型</li></ul><p>将项目中configs&#x2F;model_config.py里面的LLM_MODELS里面增加上chatglm2-6b，EMBEDDING_MODEL配置上m3e-base。配置完之后，才会在启动的时候使用下载的这两个模型，要不然会使用默认的模型。chatglm3-6b和bge-large-zh-v1.5。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310193905361.png" alt="image-20240310193905361"></p><p>tips：因为上面说的这两个模型是已经有开发者验证过的所以在下面的模型列表里面是有的，下载完模型，修改下配置文件就可以用。但是如果模型列表里面没有的模型加载进来，不一定可以跑。这个要注意下！</p></li></ul><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310193814840.png" alt="image-20240310193814840"></p><ul><li><p>启动项目</p><p>如果什么问题到没有出现的话，就会是这样一个界面，上面会显示加载的LLM模型，使用的Embedings模型，项目api文档地址和webui的地址。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310194211001.png" alt="image-20240310194211001"></p></li></ul><p>​       可以看到我们可以访问本地的8501端口就可以进入到web界面。</p><p>​<img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310194452916.png" alt="image-20240310194452916"></p><ul><li>实践效果</li></ul><p>使用本地机器跑模型的效果，虽然这个图里面是回答得感觉还行吧，但是实际我问一个问题，回答需要可能10分钟才能返回完结果。可能是因为这个确实挺需要硬件资源的，我本地就一块显存8G的显卡，能跑起来，我已经是谢天谢地了。而且我还找了些资料去优化，将FP16的模型弄成int8的模型去跑，但是不知道是我方式不对还是，硬件资源不够，跑出来的效果也还是很慢。所以如果想要商业化之类的，硬件资源还是得给够，或者走大模型的api调用。我这个只能说是个人学习使用下，连流畅的效果都达不到，哈哈哈。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310181143407.png" alt="image-20240310181143407"></p><h1 id="3-遇到的问题"><a href="#3-遇到的问题" class="headerlink" title="3.遇到的问题"></a>3.遇到的问题</h1><p>3.1 python安装库特别慢，查了一下，如果运行 <code>pip config list</code> 返回空值，表示没有明确在配置文件中设置源地址。在这种情况下，pip将使用其内置的默认源，即 <a href="https://pypi.org/simple%E3%80%82ping%E4%BA%86%E4%B8%80%E4%B8%8B%E8%BF%99%E4%B8%AA%E5%9C%B0%E5%9D%80%EF%BC%8C%E6%97%B6%E5%BB%B6%E6%9C%89%E5%87%A0%E7%99%BE%E6%AF%AB%E7%A7%92%EF%BC%8C%E8%80%8C%E4%B8%94%E4%B8%A2%E5%8C%85%E4%B8%A5%E9%87%8D%E3%80%82%E5%90%8E%E6%9D%A5%E6%9F%A5%E4%BA%86%E4%B8%8B%E8%B5%84%E6%96%99%E6%8D%A2%E6%88%90%E4%BA%86%E6%B8%85%E5%8D%8E%E7%9A%84%E6%BA%90%EF%BC%8C">https://pypi.org/simple。ping了一下这个地址，时延有几百毫秒，而且丢包严重。后来查了下资料换成了清华的源，</a></p><p>设置步骤如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-meta"># 在命令行输入</span><br>pip config <span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span>.index-url https:<span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple</span><br></code></pre></td></tr></table></figure><p>3.2 下载模型的时候git clone连不上服务器</p><p>方法一：</p><p>发现访问这个模型需求一些科学的手段，直接浏览器可以访问到<a href="https://huggingface.co/THUDM/chatglm3-6b%E7%9A%84%E6%A8%A1%E5%9E%8B%EF%BC%8C%E4%BD%86%E6%98%AFgit%E4%B8%8D%E8%A1%8C%EF%BC%8C%E4%BA%8E%E6%98%AF%E4%BD%BF%E7%94%A8%E4%BA%86%E4%B8%B4%E6%97%B6%E4%BB%A3%E7%90%86%E3%80%82">https://huggingface.co/THUDM/chatglm3-6b的模型，但是git不行，于是使用了临时代理。</a></p><p>设置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在命令行输入</span><br> git <span class="hljs-built_in">clone</span> -c http.proxy=<span class="hljs-string">&quot;http://127.0.0.1:1001&quot;</span> https://huggingface.co/THUDM/chatglm2-6b<br> <br> git <span class="hljs-built_in">clone</span> -c http.proxy=<span class="hljs-string">&quot;http://127.0.0.1:1001&quot;</span> https://huggingface.co/BAAI/bge-large-zh<br></code></pre></td></tr></table></figure><p>这个代理的端口就用自己平时完成科学访问的端口。</p><p>方法二(推荐)：</p><p>另外一种方式就是访问国内的魔塔网站下载（modelscope），进入到模型库的栏目，</p><p>搜索对应模型，然后点击下载。以chatglm2-6b为例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://www.modelscope.cn/ZhipuAI/chatglm2-6b.git<br></code></pre></td></tr></table></figure><p>因为是国内直接下载，方法二比方法一还是快很多，推荐使用这个方式。</p><p>3.3 报错ModuleNotFoundError: No module named ‘pwd’</p><p>这个报错来自于我一开始是在windows系统上部署的，发现官方推荐的系统是ubuntu，我本地是用的windows系统，执行启动脚本的时候需要使用到linux的pwd的命令。windows里面是没有这个命令的所以报错了，本来想改写下这个脚本使用windows对应pwd的命令去处理。但是一想，万一后面还有其他地方也用了只有linux存在的命令，那改起来的地方就多了，还是老老实实的用linux系统吧。所以后来重新弄了下windows11的WSL，用WSL可以在windows系统下安装linux的子系统，然后让Chatchat在linux子系统里面跑应该就没问题了。</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-comment"># 在windows11命令行执行，如果没有安装过这个，可以自己看下最下面的参考资料有提到怎么在windows11上开启wsl，主要是有一些虚拟机开关要打开。</span><br>wsl <span class="hljs-comment">--install</span><br></code></pre></td></tr></table></figure><p>这里简单提一下默认的ubuntu的目录和windows的系统磁盘的对应关系，在unbuntu里面进入到&#x2F;mnt目录，然后比如你要进入win的d盘，就输入cd &#x2F;mnt&#x2F;d就行了。其他盘符也是一样的道理。</p><p>3.4 安装qwen的模型报错</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240309145022872.png" alt="image-20240309145022872"></p><p>这个问题来自于准备使用通义千问的模型，然后需要启动chatchat提示需要安装一个fast-attention的包，上面这个图就是安装fast-attention报的错。因为我本地的cuda是没有加入到环境变量里面的，所以报错了。后来我下载了一个cuda11.5，结果继续报错，查资料说是要11.7以上。后来又卸载了，更新成cuda12.2才可以。</p><p>3.5 register_controller报错</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310195600397.png" alt="image-20240310195600397"></p><p>这个报错是提示register_to_controller报错，是问了交流群里面的人才解决的，是因为我本地起了全局代理，然后这个是注册应该走到代理的网络上去了。关闭了代理或者PAC模式之后，wsl要重新启动一个新的会话，然后再启动项目就可以运行了。</p><p>3.6 chatchat开启量化模型</p><p>这个问题是来源于我感觉本地的llm返回很慢，所以查了下资料怎么优化返回速度。发现可以修改项目中configs&#x2F;server_config.py里面的load_8bit参数。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310200634568.png" alt="image-20240310200634568"></p><p>开启之后，启动项目的加载模型的日志里面会多一行’load_8bit’: True的日志，表示开启8bit量化成功。这个原理大概是这样一个意思，本身模型的计算可能小数位很长，假设有16位，开启之后把16位转为8位或者精度更低的位数，这样计算的时候就会更加迅速，不过带来的问题就是可能结果没有之前准确。不过我试了下开启之后，我主观上没有觉得它返回变快了，不过群里的朋友说开启之后是挺快的，这个效果我是没有办法百分之百说有效，读者可以自行尝试一下。</p><h1 id="4-项目结构"><a href="#4-项目结构" class="headerlink" title="4.项目结构"></a>4.项目结构</h1><p>自己理解的项目结构，可能不完全准确</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240311080104198.png" alt="image-20240311080104198"></p><p>官网放的Chatchat处理流程图，如果看过langchain的资料的话，会发现中间主要是langchain的处理过程，因为这个项目也是基于langchain去做的。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310202107156.png" alt="image-20240310202107156"></p><p>文档处理流程</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240310202128044.png" alt="image-20240310202128044"></p><h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h1><p>虽然使用Chatchat整个过程中的坑还是挺多的，但是至少跑起来了，而且在跑这个项目中遇到了很多自己没有接触过的知识。比如量化模型这个概念，是在优化返回速度的时候才知道可以把模型的精度改小，提高计算速度。现在本地还只运行成功了项目本身支持的几个模型，像界面中的知识库问答，文件对话，搜索引擎问答，自定义agent都还没跑成功，还有挺多东西要去研究和尝试的，还是挺有意思的。我想了想后面可能会针对其他的几个模式也写一些记录。</p><h1 id="6-参考资料："><a href="#6-参考资料：" class="headerlink" title="6.参考资料："></a>6.参考资料：</h1><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">1.如何使用 WSL 在 Windows 上安装 Linux</a></p><p><a href="https://www.tjsky.net/tutorial/667">2.本地安装部署运行 ChatGLM-6B 的常见问题解答以及后续优化</a></p><p><a href="https://github.com/chatchat-space/Langchain-Chatchat">3.LangChain-Chatcaht项目地址</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2024/02/17/2023%E5%B9%B4%E5%9B%9E%E9%A1%BE/"/>
    <url>/2024/02/17/2023%E5%B9%B4%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>2023年回顾</p><h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><p>上班的日子渐渐靠近，年味的假期也快消耗殆尽，趁着无人打扰，静静的坐在书桌前，想想去年一年发生的事情。桌上放一杯刚冲泡好的岩茶，香气四溢，浓郁茶香沁人心脾，小酌一口，刚开始有些烫嘴，在口中停留片刻，一饮而下，茶香味从喉部返回到口中，回甘绵长，再看看自己贴在墙面毛毡板上的2023年计划便签，有超标完成的，也有压根没去尝试的，心中升起一丝自嘲的想法，嘴角便上扬了起来，哼哼笑出了声。看完了计划，再解锁手机，瞅瞅自己的相册，往下滑一滑看看这一年去了哪些地方，珍藏下多少美丽的风光和印象深刻的回忆。</p><h1 id="2023年回顾："><a href="#2023年回顾：" class="headerlink" title="2023年回顾："></a>2023年回顾：</h1><h2 id="成长回顾"><a href="#成长回顾" class="headerlink" title="成长回顾"></a>成长回顾</h2><p>下面是自己将23年计划根据完成情况整理的思维导图：</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240217172844971.png" alt="image-20240217172844971"></p><h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><p>书籍里面《穷查理宝典》，《运动改造大脑》，《我的事业是父亲》这三本比较推荐的。</p><p>《穷查理宝典》我去年的书单里面其实就有了，之前看的都是电子版的，今年芒格去世了，缅怀下芒格先生就又买了纸质版本的《穷查理宝典》, 《芒格之道》（这本书都是芒格在股东大会上的讲话），重新看了一遍这些书，里面有很多普世智慧值得我们学习。举个例子，**芒格说“我这辈子遇到的聪明人没有不每天阅读的，没有，一个都没有。沃伦读书之多，我读书之多，可能会让你感到吃惊。我的孩子们都笑话我，他们觉得我是一本长了两条腿的书。” **这就是教导人们要多阅读多学习，即使咱们做不到像芒格一样每天阅读，多抽点时间阅读总还是做得到的，正所谓开卷有益。这本书很多人都以为是讲金融理财投资方面的知识，其实这只是里面的一小部分而已，有关人生的普世智慧，学习思考方法，做人的准则，投资理念等等都有讲到。如果你想知道大佬是怎么学习，思考的，那我建议你好好读读这本书，你一定会有很多收获的。</p><p>《运动改造大脑》这本书其实很简单，核心思想只有一个，就是运动对你学习和生活有很多帮助。只是这本书用活生生的例子，和各种科学的理论依据介绍了运动对压力，学习，专注力，抑郁等多方面的积极作用，所以身体是革命的本钱，多多运动对你整个人身体和精神都有很好的塑造作用。</p><p>《我的事业是父亲》这本书是因为老婆怀了小宝宝，所以开始思考以后孩子的教育问题，才看的书。这本书的核心思想是早教，0-6岁对孩子多多培养，开发孩子的各方面能力。此书的作者蔡笑晚的六个孩子有五个都是博士，而且不是那种普通学校的博士，好几个都是美国知名大学的博士，所以这个对孩子教育的方法应该还是比较正确的，在他们家里有一定的可复制性。我也想把孩子培养成优秀的人才，所以我看了好几遍这个书籍，到时候结合自身的情况，对孩子做出相应的早期教育，希望孩子也能成为一个国家的栋梁之材。</p><h2 id="生活回顾"><a href="#生活回顾" class="headerlink" title="生活回顾"></a>生活回顾</h2><p>每一年的生活，当我开始在脑海中回想这一年发生的事情，总感觉和去年差不多，又感觉好像和去年不一样，有这种迷迷糊糊的感受。咋一想，感觉23年有好多我的同学结婚了，包括又不限于初中，高中，大学同学，同事，可能是都到了这个结婚的年龄段，都开始发力了。又一想，今年在省内还去了不少地方游玩，今年的闲暇时光过得还挺充实的。如果不是手机记录的照片和计划的记录，我都记不太清这些过程的细枝末节了，或许真的是时间过得太快了，偷偷的从指缝中溜走，让人察觉不到，生活琐事不记录了，就记下印象比较深刻的几件事。</p><p>1.搬进了新房子</p><p>2.老婆怀上了宝宝</p><p>期房就是这样还没住上新房就还了好几年的房贷，总算在今年交房后搬了进去，以后可以不用受到房租房贷的混合双打了，自己的小窝当然是喜欢的不行，买东西再也不用在意以后搬家麻烦不麻烦的问题了，采光通风什么的也比之前租房好上太多。</p><p>不过最开心的事情还是老婆怀上了小宝宝，一开始和老婆就计划好了等搬进新房子在生娃，租房里面又小又不好带娃。感觉明年生完孩子之后，可能生活的重心就会放到孩子身上了，有娃没娃心态完全不一样，自从老婆怀上后，我心里就只有一件事情了，要让小宝宝健健康康的成长，那种父亲的责任感，使命感，对孩子的喜欢对孩子出生的期待，天呐！我也要当父亲了！稍微能体会到父母对自己的爱的那种感觉了。到现在写文章的这个时间，胎儿已经好几个月了，每天下班回家我就只想给宝宝做胎教，给宝宝讲故事。胎教这件事我还特意查了一下时候有没有科学根据，我查的资料是说网上说胎教并没有明确的科学依据会让宝宝更加聪明，不过因为讲故事会让孕妈妈心情很放松，很开心，宝宝的发育就会很好，孩子自然就棒棒哒，所以我还是隔三差五会讲讲故事，放放轻柔的音乐，这样对娘俩都好。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>自己总结就是23年的目标总体还是比较满意的，有好几项是超额完成了，虽然也有两项没完成，但是这两项我本身也没有投入很多精力，对目标完成的渴望并不高，所以我也没有很大的挫败感。对比22年的学习情况来说的话，还是有很多进步的，根据这一年计划的完成情况，对24年指定计划也有了一些新的体会和想法。</p><p>1.阅读书籍这种，不应该追求书籍的数量，而应该根据阅读时长来设定目标。因为有的书就短短一两百页字还很大，有的书有七八百页字还很小。如果光追求本书的话，多读点一两百页的书，数量就上去了，但是这样没有意义，阅读主要还是要找到自己想学习的一些东西去理解，消化，吸收，不在于书籍的数量，而要看整体花的时间，假设每次阅读的效率是一样高的情况下，阅读的时间越长，知识掌握的阅读，应该根据阅读时长来指定计划。</p><p>2.另外看一本书我觉得没有必要全部看完，有些技术书籍，前面的章节可能都是自己清楚的，只需要取我所需，阅读自己不熟悉的部分即可。</p><p>3.关于写博客&#x2F;笔记这种，我认为还是要写的，需要自己输出来强化自己的知识梳理和记忆。说实话很多时候就是自己学习完之后，懒得动笔，所以博客写的一年比一年少（当然自己比较忙也是一个比较实际的借口），以后除了技术方面的文章，其实读书笔记，生活方面的感悟之类也可以写一些，只要在输出就是好的，文笔锻炼不能落下，既要能说又要能写。</p><h1 id="2024年计划"><a href="#2024年计划" class="headerlink" title="2024年计划"></a>2024年计划</h1><p>结合上面的一些思考，指定了24年的计划。</p><p>1.阅读不再追求数量，按照时间来统计，一年365天，只要累计起来有365小时就算完成，平均起来算每天阅读一小时</p><p>2.锻炼还是继续保持，23年很快就完成了45次的标准，24年多加一点，52次平均就是一周一次。</p><p>3.文笔锻炼还是要继续，只是要求要降低了，三周一篇，一共18篇就算完成，可以多写写读书笔记，感悟之类的，不局限于技术文章，23年是只写了一半，24年加油！不过考虑到明年孩子出生，肯定会有大把的时间花在小宝宝身上，所以明年其实我也没有对自己的学习成长抱有很高的期望，只要能完成阅读和锻炼，写博客完成与否其实也不做强制要求了，作为可选完成项目。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20240217201336764.png" alt="image-20240217201336764"></p><p>最后祝各位读者新年快乐！身体健康！龙年大吉！龙马精神！龙年都能完成自己小小目标~走上人生巅峰！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/11/05/2021%E5%B9%B4%E5%9B%9E%E9%A1%BE/"/>
    <url>/2023/11/05/2021%E5%B9%B4%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本来也不打算写年终总结了，毕竟公历和农历年都过了，但是想想之前也没有正式写过什么年终总结，现在开始每年写一篇，等到自己年纪大了，在翻看自己年轻时写下的一篇篇回忆录，看看当时的自己正在干什么，也还是挺有趣的，否则时间太长的话就真的不记得当时做过些什么了。很多年之后再翻看的时候，和当时写记录的时候对比心情肯定也不一样了，所以还是有必要写点啥。于是开始拿着手机的照片和记录翻阅，看看自己2021年都干了些啥。</p><h2 id="1-体育锻炼"><a href="#1-体育锻炼" class="headerlink" title="1.体育锻炼:"></a>1.体育锻炼:</h2><p>从过年之后开始上班，在3月份有了一个很大的转变就是加入了公司的健身小分队，开始锻炼身体，想想自己从毕业之后基本上很少参加体育锻炼，身体素质确实下降了很多。<br>想起以前在学校的时光，在杭电的时候还有阳光长跑和体育课，阳光长跑这个是学校响应教育部出台的一个政策，每个大学生都必须一个学期完成指标的次数，好像是要算到学分里面之类的。<br>这个政策还是挺好的，很多同学那时候都不怎么锻炼身体，这个硬性规定至少在一定程度上提高了大家的身体素质和跑步水平。虽然也衍生出了一些代跑的赚钱路子，有些人不想跑就出钱，让其他人帮忙拿着自己的<br>学生卡去跑步，刷卡，还有人骑自行车刷跑步次数，学校后来也加强了监管，有学生会的人在刷卡点检查学生是否真的在跑步。现在想起来还是挺有意思的，真实的魔高一尺道高一丈，哈哈哈。</p><p>在说回来，因为公司有几个同事经常锻炼，然后我又觉得上班总是一直坐着，对身体当然是不好，所以决定加入他们，一起锻炼身体，毕竟身体是革命的本钱，健康是第一。我们基本上是一周锻炼两次，<br>周二周四每晚锻炼一个小时，中间因为各种事情也修改过锻炼时间，不过基本上是一周两次。从三月份开始到十二月差不多九个月的时间，那基本上锻炼了72次左右吧，对自己来说还是一个很不错的成绩，<br>毕竟毕业后这几年都没锻炼过，去年也算毕业后的体育锻炼的大突破了。</p><p>附上自己锻炼的记录，有一些因为带着手环就记录下来了。<br><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a62a526341db4405acc0abaf1c48f7bd~tplv-k3u1fbpfcp-zoom-1.image" alt="总的锻炼记录"></p><h3 id="1-1-游泳"><a href="#1-1-游泳" class="headerlink" title="1.1 游泳"></a>1.1 游泳</h3><p>顺着锻炼身体这一块在来谈谈去年和往年不一样的地方是顺便学会了游泳，以前只是和小伙伴去游泳池玩过几次水，也不会游泳，这个夏天同事突发奇想说要去游泳，然后我也就买了装备跟着去了。结果发现同事的游泳是自己学的，游不了很远，于是回来后自己开始研究怎么学会游泳，<br>在网上看了很多游泳自学的视频，看的最多的还是梦觉教游泳，双旭教游泳，Aimee游泳学堂几个博主的视频，梦觉的视频真的是搞笑。一起混合起来看总算把蛙泳学会了，可以在50米的泳池游好几个来回，自我感觉良好，基本上算学会游泳了。后来又了解到蛙泳比较伤膝盖，所以又开始自学自由泳，<br>实际上应该是叫爬游，科普一个小知识，自由泳中最常见的是爬游，所以大多时候，大家说自由泳指的是爬游，其实奥林匹克自由泳就是随便你怎么游，只不过又省力又快的是爬游，渐渐的自由泳就在人们的意识中等同于爬游了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d8c76493ec74df8a66b897d9f6ae9b8~tplv-k3u1fbpfcp-zoom-1.image" alt="游泳记录"><br>在来说爬游，这个简直难学，蛙泳其实看了视频游了几次我就学会了，即使动作不标准也可以游起来，可能小时候在河边玩的比较多，水性比较好，不怕呛水。但是爬游这个我按照教程分别练了打腿，划手，然后配合呼吸，最后合到一起练，都不得要领，配合起来非常难。而且打腿这个本来拿着浮板打腿感觉自己还挺行，<br>一到手脚配合，就完全乱套。至今还没有完全学会爬游，我感觉爬泳这个侧身的翻转可能是最难的，每次我再翻转的时候很难做到呼吸不呛水，每次呛水后，我就赶紧变回蛙泳，蹬几次腿，划手，仰头，赶紧把呛得水呼出来，在吸一大口气。就是这样练爬游，失败转蛙泳蹬腿，练了很多次。希望2022年可以学会吧，算是2022年的一个小目标吧，毕竟会爬游可太酷了，又省力，又不伤膝盖，还能锻炼身体，<br>保护我这每天劳累的腰椎颈椎。<br>再来扯一扯游泳的好处，咱们上班族每天的面向桌椅劳动，对腰椎颈椎的伤害很大，游泳因为是趴在水面上的，而且因为要在水上呼吸，会一直活动自己的颈椎腰椎。练蛙泳的时候真的很有感觉，因为本来是面部在水里的，朝向水的，要呼吸的时候必须要把头仰起来到水面上，一直游就会一直在活动颈部，简直就是为恢复颈椎量身定做的姿势。</p><h2 id="2-生活"><a href="#2-生活" class="headerlink" title="2.生活:"></a>2.生活:</h2><h3 id="2-1-婚礼"><a href="#2-1-婚礼" class="headerlink" title="2.1 婚礼"></a>2.1 婚礼</h3><p>接着看照片发现时间来到了5.2号，今天可能最重要的事情就是它了吧，今年结婚啦。2020年跟老婆领了结婚证，在这几年疫情肆虐的时光里，我们算是挑准了一个好日子，在疫情没有那么严重的时期，把大家聚起来，见证了我们的美好时刻，我有一些朋友也因为疫情的原因导致婚礼一推再推，婚礼和酒店就会很难安排，邀请亲朋好友也会变得异常麻烦。我们提前了几天回来，把各种事情都准备好，其实主要是父母在忙活，他们基本上把要准备的事项和东西都准备好了，我们主要是婚礼的排练和一些招呼客人的事情。<br>那天天气很好，早早的就起床，然后去弄婚车啥的，这个时间我老婆应该在化妆等着我们去接驾，然后婚车和捧花，胸花啥的都弄好就从我家里出发去接我老婆。到了那边后，经典的难为新郎的事项就开始了，堵门啊，做游戏啊，找新娘的鞋子呀啥的，好在我的伴郎兄弟都很给力一一化解，最好笑的是，堵门的时候是老婆家的们坏了，哈哈哈。真正的打不开了，我有个发小是搞健身的，直接把门把手给掰断了，我还记忆犹新。后来接到新娘去酒店，然后迎接新朋好友。最后仪式开始，和老婆来了一次情歌对唱，婚礼上做了一次不错的演讲，被长辈们夸奖了，说这孩子有出息，哈哈哈。不过回想起来有点遗憾的是，我没有安排好我的同学们，进来让同学坐到了离门口比较近的位置，离舞台有点远，那天在酒店迎宾没有想到座位的问题，后来被老婆提醒了才确实发现是自己没做好，应该把同学们接到舞台前面一些的位置。还是考虑不周，以后比较大的事情应该要注意这些事项。</p><h3 id="2-2-汽车"><a href="#2-2-汽车" class="headerlink" title="2.2 汽车"></a>2.2 汽车</h3><p>写着写着觉得时间过得真的好快，这个想法一定不是只有我一个人有过吧。今年还重新学会了一个技能，就是开车。重新学会的意思是，因为我有驾驶证，以前也会。但是自从考完驾驶证之后，基本上没有开过车，因为我家没有买车，只有节假日的时候用亲戚的车练几下，所以开车技能基本就在拿完驾驶证后就被冻结了。从16年考完驾驶证后，已经过去了5，6年，我的驾驶证都换过一次，升级为5年驾龄的老司机了，但是技能点是灰色的。因为今年摇到了车牌，然后快到期了，不想失去车牌被迫买车。汽车对于现在的我来说，有用但没有特别大的用，我还是觉得骑小电驴方便，想停哪就停哪，所以说是被迫买车，主要是车牌太难摇。说来也巧，我前几年就摇过几次车牌，都没中，就没摇了，去年刚好有个朋友从北京调来杭州工作，跟他聚会吃了顿饭，他问我摇车牌没有，我说没摇了，他笑着说干嘛不摇反正又摇号不要钱，于是我就又开始摇号，然后摇了几次就中了，真是神奇。</p><p>摇中了后，因为摇号有效期期限有一年，所以前半年没怎么管，打算开始是买个五菱宏光先把车牌上了就行了。后来还有几个月快到期，就开始学车，找了个陪驾，和老婆练了几次，花了好几百大洋，练得差不多了。这里感觉陪驾真是不错，比考驾照的教练温柔太多，教的也是干货，生活中开车用得到的技能。接着准备开始看车，本来是打算买个二手车，怕自己看不好，放弃了。想买五菱宏光mini，觉得很便宜，跟家里人和朋友说了之后，被各种劝，说不安全不经撞，会被人笑话，车要用很久等等理由，纠结了很久，打算还是买个轿车，于是乎开始疯狂补汽车知识，估计花了好几周的时间，从一个对汽车完全不懂的小白，变成了一个汽车有所了解，能说出个这个车巴拉巴拉一二三的人，之后买了一辆轿车，价格基本在自己承受范围之内，我和老婆也很喜欢，也是我们人生中第一辆车了。</p><h3 id="2-3-出行"><a href="#2-3-出行" class="headerlink" title="2.3 出行:"></a>2.3 出行:</h3><p>对了，今年还抽空出去玩了，去了乌镇和西塘，乌镇挺好玩，西塘感觉一般，主要是这两个位置景物差不多，去了乌镇再去西塘就感觉没啥意思了，还去完了一次漂流，夏天的漂流真的很好玩。</p><h3 id="2-4-疫情"><a href="#2-4-疫情" class="headerlink" title="2.4 疫情"></a>2.4 疫情</h3><p>时光匆匆就到过年了，本来是买的29号的票，准备回家，结果27号早晨上班被大白（防疫人员的萌萌的称呼）拦住了，说我们小区被管控了，我顿时一头的问号。啥？咋回事？不会吧？我昨天还好好的，今天小区就被隔离了？然后知道是有个阳性的新冠患者，在我们小区住过一晚，所以我们整个小区都被封控了，只进不出。但是一直没有通知要什么时候解封，直到2月5号才发通知说要封控到10号。就这样，今年过了一个最特殊的年，在小区的出租房里面和老婆渡过了一个估计一辈子都不会忘记的新年，被封控的这些天，基本上天天要被大白捅喉咙，做核酸，一日三餐天天吃盒饭。过年那几天送了一个大礼包，里面有鸡鸭鱼等食材之类的。年后开始有了外卖可以点，社区也有零食和水果免费送。不过天天的娱乐活动就是看电影电视剧动漫，打游戏，偶尔学习看看书之类的，在写这篇随笔的时候，本人还在封控，哎，看着盆友圈大家发出的一个个有年味的文字和图片视频，还是会有些难过的。不过也算为防疫做了一点贡献吧，不吵不闹过了这么多天，服从上级安排。防疫人员确实也挺辛苦，听老婆说在封控的小区的群里，有一个防疫的女孩过年都哭了，从早上五点钟就过来小区帮忙，没吃午饭也没去上厕所。大白之所被称为大白，是因为他们要传厚厚的隔离的衣服，衣服颜色是白色的。这里给防疫员人点个赞，确实很辛苦，也感谢这么多天他们对我们的照顾。我们失去的是15天的自由，他们也是，他们还同时要照顾我们，服务我们，安抚隔离人员的情绪之类的。话说这次过年还真是省了不少钱，十五天的一日三餐，还有过年大礼包啥的，我愿称之为目前最省钱的一年，哈哈哈。</p><h2 id="3-学习"><a href="#3-学习" class="headerlink" title="3.学习:"></a>3.学习:</h2><p>最后看了下今年写的博客数量是18篇，基本上是三周一篇，比去年两周一篇还少，越来越懒了，22年要加油啦。说实话技术文章有时候真的挺难写，我觉得可以多写写看的书，见闻之类也可以，凑个数也是在锻炼文笔，总比不写要好。然后看了下自己今年leetcode的刷题量10几道，22年先不过分要求了，毕竟和是自己的短处，先做到今年52道题，算一周一道。今年看书情况是7本，《设计模式之禅2》，《大型网站技术架构》，《SpringBoot实战》，《刷新》，《睡眠革命》，《放学后》，《小岛经济学》，本来计划是一个月一本一共要看12本，结果也没有达成。其实技术类和资料也看了不少，不过没法量化，就不多讲了。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结:"></a>4.总结:</h2><p>最后来总结看下，发现自己成长和学习上列的计划基本上都没有达成，只完成了一部分，打脸了，这是22年要加强的部分。生活上的东西倒是完成了不少人生的任务，这几年感觉变化很快，被生活推着走，拥有了很多以前在大学，在没工作之前没怎么考虑过的东西，有时候可能就是这样，不是自己想变成熟长大，而是被生活推着成长。很多跟我差不多的朋友，聊天的时候都觉得自己还是孩子呀，怎么就要结婚生子，成为父亲母亲了呀。可能孩子和大人并没有很明显的界限，主要是心态吧，要去主动承担一些责任。最后还是觉得今年要好好计划一下自己的学习计划了，今年学习成长有点松懈了。2022加油！</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2023/11/05/2022%E5%B9%B4%E5%9B%9E%E9%A1%BE/"/>
    <url>/2023/11/05/2022%E5%B9%B4%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>2022年回顾</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>新年和亲朋好友的相聚差不多接近尾声，假期也所剩无几，开始静下心来写作，回顾一下我的2022年，看下自己去年</p><p>做得好的和不足，展望下2023，开始新一年的生活。（因为是公历2023年写的文章，所以文中所有的去年都是指的2022年）</p><p>一年的时间其实还挺长的，回忆起来经历了很多事情，但是事情仿佛都是一件件被记录在脑海，没有时间关联，好在手机里面储存了一些照片，能够帮助串起这些时间的碎片。所以我在想平时可能还是需要多拍拍照片，往后才能更好的回忆往昔的生活。随着一张张照片在眼前不快不慢的扫过，中间看到印象深刻的事情略作停顿，嘴角微微上扬，看完之后对自己这一年有了一个大致的印象，以下按照几个大块来分别回忆总结下。</p><h1 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h1><h2 id="1-体育锻炼"><a href="#1-体育锻炼" class="headerlink" title="1.体育锻炼"></a>1.体育锻炼</h2><p>去年上半年还是跟同事一起在公司楼上的健身房挥汗如雨，坚持的比较好，到下半年去七月份开始因为出差了一个月，回来后发现其他几个同事就没有继续去锻炼了（果然懒惰是会传染的，有一个人不参加，大家的积极性就会急剧下降）。然后我们的锻炼小组直接解散，只能靠自己约束自己来锻炼了。正好七月份天气也热了，继续着我去年给自己定的游泳计划-学会自由游，也继续着自己体育锻炼的计划。</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/2022%E4%BD%93%E8%82%B2%E9%94%BB%E7%82%BC.jpg" alt="2022体育锻炼"></p><h3 id="1-1-游泳"><a href="#1-1-游泳" class="headerlink" title="1.1 游泳"></a>1.1 游泳</h3><p>严格来说我2022年定的目标学会自由泳并没有完成，因为我没法长时间进行自由泳，这个长时间我认为是至少要达到100米吧，差不多能完成自救。我实际完成的效果是能自由泳25米很轻松，50米很勉强。但是我看网上视频教程说会25米就算学会了，只是要优化自己的泳姿来达到长时间的游泳。我觉得自由泳比蛙泳要难上不少，首先自由泳的换气，网传的“半镜换气”，真的很难，就是水要没过半只泳镜，同时完成换气，因为这样的姿势换气时间很短，很容易换不到气，换不到气，人就会缺氧变的慌乱，造成力竭。另外一个难点就是需要自己整个身体一起跟着在水中转动，要核心肌肉群控制住自己的身体才能保证在水中保持翻转的同时是平衡的，不会晃动到自己无法控制。</p><p>我是看着视频学习，然后用A字板，单手滑水反复的练习在加上双手扶A字板打腿练习，才勉强掌握了自由泳的技巧。当然还有很多提升的空间。随着游泳越来越多，水性越来越好，我自己尝试的仰泳，就直接学会了，这个比自由泳和蛙泳还简单，主要是要克服仰泳头向后倒的恐惧就行，打腿跟自由泳一样，而且更轻松，就像在水中躺着走路一样，一点都不会累是最省力的泳姿。对于2022年的游泳我自己觉得还是算满意的，学会了仰泳，半会了自由泳，今年在继续加油，争取自由泳能不费力的游个一百米。</p><h3 id="1-2-马拉松"><a href="#1-2-马拉松" class="headerlink" title="1.2 马拉松"></a>1.2 马拉松</h3><p>今年比较特殊的是参加了一次半程马拉松，本来是抱着试一试的心态去马拉松摇号，结果摇中了，要知道我至少摇号摇了五次，头一次中奖。从摇号到参赛，中间一共就只有九天的时间，我中间训练了几次，然后就直接去跑了。还好我平时有锻炼身体，要不然可能还真完不成，最后用了两个半小时完成了21公里。对此，我给自己打满分，从来没参加过马拉松，竟然还真的完成了，成绩还可以。对2022年来说真的是一个很特殊的体验和经历。希望后面还有机会继续参加，那我就好好的准备，周到的备战。参加马拉松给我最大的感受就是，你完全不用在意别人之前超过你，或者速度比你快。只要你不停下，即使速度很慢，也没关系，每个人都有自己的节奏，坚持就是胜利，只要能完成，挑战自己就成功了，就是最大的胜利。</p><h2 id="2-学习"><a href="#2-学习" class="headerlink" title="2.学习"></a>2.学习</h2><h3 id="2-1-阅读"><a href="#2-1-阅读" class="headerlink" title="2.1 阅读"></a>2.1 阅读</h3><p>去年给自己定的计划是看12本书</p><p>今年完成阅读的一共六本：</p><p>《认知红利》</p><p>《为什么精英这样用脑不会累》</p><p>《贪婪的多巴胺》</p><p>《小狗钱钱》</p><p>《穷查理宝典》</p><p>《全球通史》</p><p>还没读完的有三本：</p><p>《激荡的三十年：中国企业1978-2008》</p><p>《知识的错觉》</p><p>《微服务架构设计》</p><p>没有达到去年的计划，未看完的三本今年2023年补上，然后2023年的计划依然是看12本书，加油！多花点时间阅读，减少自己玩耍的时间，相信自己肯定可以完成。</p><p>推荐的书籍有《穷查理宝典》，《激荡的三十年》，《微服务架构设计》。这三本书我觉得是写的比较好的，三本书都属于不同的领域，但是都给了我很多启发，特别是《穷查理宝典》对认知，人生观价值观有很大的帮助。</p><h3 id="2-2-LeetCode"><a href="#2-2-LeetCode" class="headerlink" title="2.2 LeetCode"></a>2.2 LeetCode</h3><p>去年计划：52道</p><p>完成度：26道</p><p>今年计划：45道</p><p>算法题这个如果只做简单题，可能数量还会提升，不过我做的都是不同类型的题目，很多题目的做法理解都要看半天，所以降低了今年的计划，周赛还是可以继续刷刷，提高自己的算法水平。算法对我来说一直是弱势项，也不要求自己有多厉害，只要能继续坚持刷题，提高自己编程水平就行，继续加油！</p><h3 id="2-3-写作"><a href="#2-3-写作" class="headerlink" title="2.3 写作"></a>2.3 写作</h3><p>去年其实技术钻研还花了不少时间，看了很多跟大数据相关的技术博客和文章，但是博客写的确实不多，总共今年就写了9篇。说实话，真的是挺少的，输出的数量太少。今年先计划恢复到两周一篇，不管是读书笔记还是技术博客，争取达到26篇。</p><h3 id="2-4-开源贡献"><a href="#2-4-开源贡献" class="headerlink" title="2.4 开源贡献"></a>2.4 开源贡献</h3><p>往年我都没有给开源社区贡献过代码，只有自己写的一些小工具，小代码库，今年打算给开源项目贡献一次，一来是提升自己技术水平，因为你只有自己水平足够，才能去解决开源社区用户提出来的问题，二来是贡献代码可以结交志同道合的朋友，三来是可以提升自己的技术影响力。今年争取找一个比较知名的开源项目，而且又跟公司业务比较相关的，去帮忙处理一些用户提出的issues。</p><h2 id="3-生活"><a href="#3-生活" class="headerlink" title="3.生活"></a>3.生活</h2><h3 id="3-1-出行"><a href="#3-1-出行" class="headerlink" title="3.1 出行"></a>3.1 出行</h3><p>去年五月份跟老婆去了千岛湖玩了一次，体验了下皮划艇和星空露营。这里提醒一句，在外面玩，千万记得涂防晒霜！五月的千岛湖，炽热的太阳，我穿着短裤，短袖，没有涂防晒霜。结果划完皮划艇后，休息了一阵子皮肤就晒红了，一连过了几个月，皮肤才恢复。我们是报的户外联盟，感觉这种年轻人的带队几日游还挺划算的，之前去漂流也是跟团，报的游侠客的团，价格也不贵，还借了我们水枪和瓢用来打水仗，还挺好玩的。十月份又去良渚博物馆和良渚古城遗址玩了下，那边位置比较偏，但是空气很清新，园区也很大，值得去玩。</p><h3 id="3-2-装修"><a href="#3-2-装修" class="headerlink" title="3.2 装修"></a>3.2 装修</h3><p>去年房子交付了，我们是弄的精装修交付，所以主要是买家具，电器之类的，这几个月可折腾坏了。柜子，餐桌，沙发，床和其他电器，窗帘，墙布等等，每个周末就去家具卖场逛，我和老婆，妈妈三人组，各种跑来跑去，对比，砍价，量尺寸，看质量，弄了好久，总算在2023新年前把东西都搞定了。也算解决完一件大事，打算把家具在晾一晾，散散甲醛等有害气体，过几个月再搬进去。</p><p>最后列一下今年的计划，今年就按照这个大纲来规划自己的空闲时间了，加油！</p><p><img src="https://wxwwt-oss.oss-cn-hangzhou.aliyuncs.com/imgRepo/image-20230127231258786.png" alt="image-20230127231258786"></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
